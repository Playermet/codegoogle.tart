// ------------------------------------------------------------------------

Design TODOS:

* Const-ness "const" and "const? / constable"
* Need a way to collect all declarations that a given attribute is assigned to.
* Collector classes:
  * TLAB
  * LinearAllocator
  * Eden
    * Linked-list of TLABs.
    * Lock for the TLAB list.
      * Each TLAB is 32k.
      * Eden size is 2 + 2 * numThreads TLABS.
      * TLABS do not need to be contiguous
      * Thread local ptr to TLAB.
  * SS1 and SS2. These have SSABs. = 50% Eden size.
  * SSAB.
  * Problems to solve:
    Still need to know how to mark objects in different spaces.
  * Some way to import C++ data structures into Tart - for things like pthreads.
  
Hard problems:
  -- GC
  -- Exception backtrace
  -- Reflection size

Working on currently:
  -- Get static ctors working.
  -- BitTricks tests.
  -- New @Reflection annotation
  -- GC
  -- Static If
  -- Compile-time configuration options. @TargetProperty.
  -- Reduce number of generated strings, or eliminate dead reflection globals. (working on it)
  -- Exception backtrace.
  -- Hashing of integers

Implementation TODOS:

* Add a unit test for converting invalid enum values to strings.
* Fix coercion of enum values to objects.

* Coalesced templates
* Case * (what about classify?)
* Open/closed intervals
* Implicit downcast in if-block. (Includes unions as well.)
* Implicit anonymous class for closure.

* Call gc_alloc instead of malloc.
* Add 'typealias' to eclipse plugin. (Also trim whitespace at ends of lines).
* Refactoring
  * Use CVQualifiedType to represent const/volatile.
  * Some means to cache relabeled specializations?
  * Finish up override keyword, with failure tests.
  * Fill out TypeOrderings.h / TypeComparator.h
  * Unit tests for lexical type ordering.
* I/O library.
* Win32
  * Find an assembler.
* Link-time coalescing (use LLVM plugin)
* typecast[type](in);
  * More tests - reference types, null pointers. (Union types are done)
* Closures - Closure cells.
* Garbage collector
* Reflection
  * Struct Constructors
  * Properties and fields.
  * Class members.
  * Find all properties/functions having some attribute
* Profiling.
* Test overloading of augmented assignment operators.
* Override for property getters and setters. (I think that's done.)
* Finish array unit tests. (One test remaining)
* Proxy types
* Integer parsing
* Exceptions:
  * Finally
    * Return
    * Break / Continue
  * Nested catch (try inside catch or finally block) - test
  * Stack trace
* Enum types
   * Enum operators (relational).
  * .parse or valueOf.
* Tuple types
  * Test struct members, params.
  * Member-wise conversions.
* Constructors
  * Insure that constructor calls aren't recursive.
  * Insure that we can't call constructors from non-constructor functions.
  * Allow overloading of constructors with functions, but don't allow two classes
    with the same template args.
  * Classes with create still need a default constructor? (Unless undef'd).
* Import-as.
* Source-level debug info.
  * Finish debug support.
  * Isolate and report bugs.
* Generator functions.
  * Yield statement.
  * State machine.
* Strings
  * Conversion specs.
  * Define toStringFmt() - custom string formatting
  * Other string-related functions
  * Characters.tart
  * text functions - substr, toLower, etc. (Character classes, need unicode stuff)
  * Unicode character class tests.
* Let with instance scope.
  * Insure that it cannot be assigned to in non-constructor.
* Disjoint types
  * Equality comparison (with member types, and with other disjoint types.)
* SourceLocation - I would like to rethink this somewhat. Right now, giving everything a source
	location means that its hard to fold constants together. Exprs really ought to be shallow.
* Type strengthening - could potentially reduce the number of vcalls and icalls (greatly).
* AttributeSite failure tests.
* Class "extension"
* Finish writing out and parsing metadata so that we don't have to compile everything
  multiple times.
* Statements:
  * with (what interface for using?)
  * yield
  * fork/threading primitives
* Tartdoc
  * Requires command-line parsing lib.
* Ranges
  * Syntax for open, closed, and half-open intervals.
  * Literals
  * As array slice indices
  * As tuple slice indices
  * Indefinite ranges (n ..) and (.. n) ?
* Generic functions.
* Complex typecast operations should probably go into their own separate functions
  instead of being inline.
* Map literals
* Matrix literals + Matrix class.
* Comprehensions
* Anonymous inner classes.
* Insure typealiases aren't circular.

Doc errors:

* Fix operator overload syntax (infixX notation used now.)
* Fix description of imports to match current functionality.
* Array literals
* Better explanation of unpacking
* Revise haskell note and next note
* Operator.add overload example.
* First line of Macro section is misleading.

Error TODOS: (things that should be an error)

* Module with multiple public names at top level.
* Assignment to a non-lvalue.
* Multiple catch statements with the same exception.* Template functions cannot be extern.
* Enforce 'readonly'
* LValueExpr.isSideEffectFree may not be true for property
  // Check for hiding similarly-named variable.

TODOS from V1 Compiler:

o  Our never-ending quest to get 'hello world' working!
  o Do we want to use stdio open() or fopen()? (Do we want to do our own buffering?)
  o Need stdin/stdout/stderr pointers.
o  Namespace merging.
o  'virtual' arguments. (Or 'dispatched')
  o  implicit convert (silent)
  o  explicit convert
  o  dynamic convert
o  Implement overriding struct assignment.

o  Type conversions of non-constants.

// ------------------------------------------------------------------------

Command to create Eclipse project:

cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug -D ECLIPSE_CDT4_GENERATE_SOURCE_PROJECT=TRUE -D LLVM_INCLUDE_DIR=$HOME/Projects/llvm-inst/include -D LLVM_LIBRARY_DIR=$HOME/Projects/llvm-inst/lib ../trunk/

Command to create Makefile project:

cmake -D CMAKE_BUILD_TYPE=Debug -D LLVM_INCLUDE_DIR=$HOME/Projects/llvm-inst/include -D LLVM_LIBRARY_DIR=$HOME/Projects/llvm-inst/lib ../trunk/

cmake -G"Xcode" -D CMAKE_BUILD_TYPE=Debug -D LLVM_INCLUDE_DIR=$HOME/Projects/llvm-inst/include -D LLVM_LIBRARY_DIR=$HOME/Projects/llvm-inst/lib ../trunk/

cmake -G "Visual Studio 9 2008" -D CMAKE_BUILD_TYPE=Debug -D LLVM_INCLUDE_DIR=C:\Users\Talin\Projects\llvm-inst\include -D LLVM_LIBRARY_DIR=C:\Users\Talin\Projects\llvm-inst\lib ..\tart\trunk

cmake -D CMAKE_BUILD_TYPE=Debug -D CMAKE_INSTALL_PREFIX=/home/talin/Projects/llvm-inst ../llvm

// ------------------------------------------------------------------------
Templates:

Variadic templates:

  class Foo:[%T, %Args...]

  def func:[%T, %Args...](t:T, args:Args...) {
    out << t;
    func(args);
  }

  def func[%T, %Args...](t:T, args:Args...) {
    out << t;
    func(args...);
  }

  def func[%T, %Args...](t:T, args:Args...) {
    out << t;
    func(args...);
  }

// ------------------------------------------------------------------------

Link-time code generation.

var s:SomeClass = injector.create();

def <T> InjectAttribute : Attribute {
  def (target:T) {
    for i in 0 .. T.params.length {
      
    }
  }
  
  def getInstance(injector:Injector) -> T.result {
    
  }
}

namespace Numbers {
  protocol PrimitiveNumber<T> {
    let minVal:T;
    let maxVal:T;
  }
  
  protocol PrimitiveInt<T> : PrimitiveNumber<T> {}
  protocol PrimitiveFloat<T> : PrimitiveNumber<T> {}
  
  protocol_map PrimitiveInt<byte> {
    let minVal:byte = -128;
    let maxVal:byte = 127;
  }

  protocol_map PrimitiveInt<short> {
    let minVal:short = 0;
    let maxVal:short = 0x7fff;
  }
  
  // This 'extend' idea is not bad. The main problem is how to represent it
  // in the compiler. We don't want to modify the original class, nor do we
  // want to interfere with the lookup of the original class.
  //
  // The rules of 'extend' are as follows:
  //
  // 1) Only protocols can be added as base classes.
  // 2) Only static or final methods can be added as methods.
  // 3) Only static or final properties can be added as properties.
  // 4) Only constants can be added as member variables.
  //
  // In other words, nothing can be added that alters the runtime representation
  // of the object.
  //
  // In some ways, this is equivalent to saying:
  //
  // class byte : byte, PrimitiveInt {
  //   let minVal:byte = -128;
  //   let maxVal:byte = 127;
  // }
  //
  
  extend byte : PrimitiveInt {
  }

  extend short : PrimitiveInt {
  }

  //extend NativePointer<byte> {
  //}

  protocol_map PrimitiveInt<int> {}
  protocol_map PrimitiveInt<long> {}
  protocol_map PrimitiveInt<ubyte> {}
  protocol_map PrimitiveInt<ushort> {}
  protocol_map PrimitiveInt<uint> {}
  protocol_map PrimitiveInt<ulong> {}

  protocol_map PrimitiveFloat<float> {}
  protocol_map PrimitiveFloat<double> {}
  

  protocol PrimitiveNumber {}
}

// ------------------------------------------------------------------------

// ------------------------------------------------------------------------

Weak references implemented in terms of finalization:

class WeakReference[%T:Object] {
  @Untraced value:T;
  
  def construct {
    value = null;
  }
  
  def construct(value:T) {
    value = null;
    set(value);
  }
  
  def get() { return value; }
  
  def set(value:T) {
    if self.value is not null {
      self.value.removeFinalizer(self.finalize);
    }

    self.value = value;

    if self.value is not null {
      self.value.addFinalizer(self.finalize);
    }
  }
  
  def finalize() {
    value = null;
  }
}  

// ------------------------------------------------------------------------

// Some way to store it as Object, but retrieve it as the original type.
// Like saying: I want you to store all occurances of T as type Object.
// Mainly this affects naming conventions for methods.

Something like [@Strict %T <: Object]

@Unsafe @Intrinsic def reinterpretCast[%T <: Object](obj:Object);

// ------------------------------------------------------------------------
flags:

  static var OutputFile = StringOption("o",
      altName="output",
      varName="output file",
      help="Path to output file"); 

abstract def foo(virtual k:Object);

override Module.foo(k:String) {
}

// Chained setter notation

object
  .(field1 = value)
  .(field2 = value)
  .build()

// ------------------------------------------------------------------------

Field:
  StaticVar
  InstanceVar
  Constant

// ------------------------------------------------------------------------

Closures:
  In parent function:
  -- convert local vars to refs.
  -- transparently box / unbox as accessed.
  
What if bound methods were a single pointer?

-- It means that a closure would need to have a vtable containing the function pointer.
   So, it would look like this:
   
      closure = { { tib, gcstate }, members... }
      tib = { .., [toString, ..., method] }
      
   Invoking a closure would always be the Nth method of the tib. (In essence closures
   would be subtypes of a 'callable' abstract class - not an interface though.)
   
So how would the 'Callable' class look?

      closure = { { tib, gcstate }, members }
      tib = { ..., [toString, ..., ..., call() }
      
   In other words, the function body would always be in the slot for the 'call' method
   of the interface. Oh, it's an interface, so it's actually:

      tib = { ..., idispatch, [toString] }
      itable = { call() }
      
   However, this only works if we know in advance the type of the interface at the
   point where the closure was defined. We can't arbitrarily convert a closure
   to a single-function interface.
   
So how would bound methods look?

  A bound method is a combination of an object pointer and a method pointer.

      bm = { instance, method }
      instance = { { tib, gcstate }, object members... }
      tib = 
      
  ...and I don't know how to do this without forwarding.

And if bound methods are two pointers, then what? How can a closure substitute for
a single-interface function?

  Again, I only see how to do this if the closure is defined at a point where the
  interface type is known - i.e. the closure has to know what interface it's being
  compiled to.

// ------------------------------------------------------------------------

// Redo Type::getHashCode();
// Make function types canonical without paramters. (Can that be done?)

Why can't we remove the names of the parameters from FunctionType? Here's an example:

  closures[index](arg=10);
  
  The type of 'closures' is: fn (arg:int)[]

// Redo pvalloc as flexAlloc. And also tie into tracer somehow (need to know length).

// CountingIterator is really inefficient. Why?
// Derived types for reflection can be deserialized in random order.

-rwxr-xr-x 1 talin talin 1386054 2010-11-07 19:56 test/stdlib/SwitchStmtTest
-rwxr-xr-x 1 talin talin 1374444 2010-11-07 21:28 test/stdlib/SwitchStmtTest
-rwxr-xr-x 1 talin talin  772508 2010-11-09 17:01 test/stdlib/SwitchStmtTest
-rwxr-xr-x 1 talin talin  363892 2010-11-09 17:03 test/stdlib/SwitchStmtTest (strip debug)
-rwxr-xr-x 1 talin talin  363943 2010-11-11 18:01 test/stdlib/SwitchStmtTest (w/downcast)
-rwxr-xr-x 1 talin talin  756752 2010-11-09 22:12 test/stdlib/SwitchStmtTest (coalesce)
-rwxr-xr-x 1 talin talin  362409 2010-11-09 22:13 test/stdlib/SwitchStmtTest (strip debug + coalesce)
-rwxr-xr-x 1 talin talin  358492 2010-11-12 19:27 test/stdlib/SwitchStmtTest (smarter coalesce)
-rwxr-xr-x 1 talin talin  357291 2010-11-13 10:49 test/stdlib/SwitchStmtTest (smarter coalesce)
-rwxr-xr-x 1 talin talin  356590 2010-11-13 11:28 test/stdlib/SwitchStmtTest (smarter coalesce)

(Need new baseline)


def callTenTimes(f:fn) {
  for i = 0; i < 10; ++i {
    f();
  }
}

def testClosureAsParam {
  var i = 0;
  callTenTimes(fn { i += 2; });
  Debug.assertEq(20, i);

  var s = StringBuilder();
  callTenTimes(fn { s.append("A"); });
  Debug.assertEq("AAAAAAAAAA", s.toString());
}

def testNestedClosures {
  let makeCounter = fn n:int -> fn -> int {
    return fn -> int {
      return n++;
    };
  };
  
  let c = makeCounter(2);
  Debug.assertEq(2, c());
  Debug.assertEq(3, c());
}

def testNestedClosures2 {
  var i = 0;
  let makeCounter = fn -> fn -> int {
    return fn -> int {
      return i++;
    };
  };

  let c = makeCounter();
  let d = makeCounter();

  Debug.assertEq(0, c());
  Debug.assertEq(1, c());
  Debug.assertEq(2, d());
  Debug.assertEq(3, d());
}
