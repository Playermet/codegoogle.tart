// ------------------------------------------------------------------------

Design TODOS:

* Type casting via operations on type objects? (for dynamic casting of reference types)
  * Something like 'object.asType(Type)' (Can't use 'as' because it's a keyword.)
* Const-ness "const" and "const?"
* Protocols
* Need a way to collect all declarations that a given attribute is assigned to.
* Need a way to iterate through all functions in a module.

Implementation TODOS:

* Refactoring
  * See if we can move template stuff into the type (CompositeType and FunctionType)
  * See if we can make UnionType and TupleType have type params like templates.
  * And native types.
  * And then make native types not require TypeDefns. (Done for Address)
  * And then make a new kind of object that represents an exported module symbol, that can
      point to either a constant or a function.
  * And then reduce the number of TypeDefns by allowing specializations to share the same
      TypeDefn object. Which means that a new template instance does not need a new
      TypeDefn.
* Boxed values: Boxed[%T] { let value:T; }. Also: auto boxing, unboxing.
* Stack dumps / trace
* Hook up TypeLess(Than).
* A way to iterate over the functions in a module...?
* Why is linking so slow? (because internalize doesn't work).
* Test overloading of augmented assignment operators.
* Constructor inheritance.
* Move stringify and locationOf to a different place.
* Finish array unit tests.
* Override and redef syntax. refine toString -> String {} "defover"?
  * How does that affect properties?
  * +def
  * Template syntax.
* Typename.type
  * Proxy
* Preconditions.verify[%T]
* Preconditions.checkState()
* Need to work on makefile dependencies.
* Exceptions:
  * Finally
    * Return
    * Break / Continue
  * Nested catch (try inside catch or finally block) - test
  * Stack trace
* Enum types
  * Enum operators (relational and bitwise).
  * .toString
  * .parse
  * Write unit tests for enum.toString()
* Tuple types
  * Destructuring assignment
  * Named tuple types
  * Variadic Tuple args
* Disjoint types
  * Cache disjoint types so that they are unique.
  * Make sure conversion works for all member types.
  * Nullable types
  * Canonical sorting order
  * Equality comparison (with member types, and with other disjoint types.)
  * dynamic casting syntax
* Multiple Return Values (requires Tuples)
* Constructors
  * init all variables not explicitly initialized in constructor, both ones with initializers
    and ones without.
  * Inherit constructors from parent class if no constructors defined.
  * Test implicit call to super() (no args) constructor if not called.
  * Insure that constructor calls aren't recursive.
  * Insure that we can't call constructors from non-constructor functions.
  * Allow overloading of constructors with functions, but don't allow two classes
    with the same template args.
* Import-as, import-namespace tests.
* Templates
  * "requires" or "where" clauses.
* Runtime
  * Compile runtime with clang so as to allow optimization.
* Source-level debug info.
* Generator functions.
  * Yield statement.
  * State machine.
* Object.toString.
* String formatting
* Let with instance scope.
* SourceLocation - I would like to rethink this somewhat. Right now, giving everything a source
	location means that its hard to fold constants together. Exprs really ought to be shallow.
* Type strengthening - could potentially reduce the number of vcalls and icalls (greatly).
* AttributeSite failure tests.
* Class extension
* Finish writing out and parsing metadata files so that we don't have to compile everything
  multiple times.
* Call gc_alloc instead of malloc. Integrate Scarcity.
* Statements:
  * for (need unpacking assignment.)
  * for/in
    * unpacking assignment
  * do-while
  * yield
  * fork/threading primitives
  * with (what interface for using?)
* String class
  * text functions - substr, toLower, etc. (Character classes)
  * character iterator functions.
* Tartdoc
  * Should it be written in Tart? Or C++?

Doc errors:

* Fix operator overload syntax (infixX notation used now.)
* Fix description of imports to match current functionality.
* Fix template syntax back.
* Array literals
* Better explanation of unpacking
* Revise haskell note and next note
* Operator.add overload example.
* First line of Macro section is misleading.

Error TODOS: (things that should be an error)

* Module with multiple public names at top level.
* Assignment to a non-lvalue.
* Multiple catch statements with the same exception.
* Template functions cannot be extern.
* Enforce 'readonly'
* LValueExpr.isSideEffectFree may not be true for property
  // Check for hiding similarly-named variable.

TODOS from V1 Compiler:

o  Our never-ending quest to get 'hello world' working!
  o Work on FileStream
  o Do we want to use stdio open() or fopen()? (Do we want to do our own buffering?)
  o Need stdin/stdout/stderr pointers.
  o Hook up C runtime. (Possibly parse C runtime into LLVM via clang.)
o  Hook up base object and type classes
o  Statements:
  o For (need unpacking assignment.)
  o Foreach (need iterators first, and static interfaces)
  o do-while
  o yield
  o repeat
  o fork/threading primitives
  o with (what interface for using?)
o  Finish writing out and parsing metadata files so that we don't have to compile everything
    multuple times.
o  Abstract class instantiation checks.
o  Namespace merging.
o  'virtual' arguments.
  o  implicit convert (silent)
  o  explicit convert
  o  dynamic convert
o  Implement overriding struct assignment.
o  GC Trace functions. (Auto-generated and explicit. Also don't take the name 'trace')
o  Add padding before static objects to make GC happy. (Maybe not.)
o  Call gc_alloc instead of malloc.
* Customizable casting support

o  Type conversions of non-constants.

// ------------------------------------------------------------------------

Command to create Eclipse project:

cmake -G"Eclipse CDT4 - Unix Makefiles" -D CMAKE_BUILD_TYPE=Debug -D ECLIPSE_CDT4_GENERATE_SOURCE_PROJECT=TRUE -D LLVM_INCLUDE_DIR=/Users/talin/Projects/llvm-inst/include -D LLVM_LIBRARY_DIR=/Users/talin/Projects/llvm-inst/lib ../trunk/

Command to create Makefile project:

cmake -D CMAKE_BUILD_TYPE=Debug -D LLVM_INCLUDE_DIR=/Users/talin/Projects/llvm-inst/include -D LLVM_LIBRARY_DIR=/Users/talin/Projects/llvm-inst/lib ../trunk/

cmake -G"Xcode" -D CMAKE_BUILD_TYPE=Debug -D LLVM_INCLUDE_DIR=/Users/talin/Projects/llvm-inst/include -D LLVM_LIBRARY_DIR=/Users/talin/Projects/llvm-inst/lib ../trunk/

// ------------------------------------------------------------------------

Permissions:

  [CompilerPermissions.Require("pointer-math")]
  
  -allow=pointer-math

// ------------------------------------------------------------------------
Templates:

Variadic templates:

  class Foo:[%T, %Args...]

  def func:[%T, %Args...](t:T, args:Args...) {
    out << t;
    func(args);
  }

  def func.[%T, %Args...](t:T, args:Args...) {
    out << t;
    func(args...);
  }

  def func.[%T, %Args...](t:T, args:Args...) {
    out << t;
    func(args...);
  }

// ------------------------------------------------------------------------

We need assertions! Which requires:
  -- Exceptions
  -- Classes
  -- isa test

// ------------------------------------------------------------------------
More template ideas:

  [Intrinsic("numeric")]
  def <N::Number> equal(a0:N, a1:N) -> bool;

  [Intrinsic("numeric")]
  def <N::Number or String> equal(a0:N, a1:N) -> bool;

  def <::Array<N:Type>> equal(a0:N, a1:N) -> bool;

  def <N == Integer> equal(a0:N, a1:N) {
  }

  def <N <= Float or Int> equal(a0:N, a1:N) {
  }

  def <:NativePointer<ElementType>> equal(a0:N, a1:N) {
  }

  def <:ElementType[]> equal(a0:N, a1:N) {
  }

  def <N::Float or Int, M:int> equal(a0:N, a1:N) {
  }

  def <N::Number, M:int> equal(a0:N, a1:N) {
  }

  def <N:Type<Number>, M:int> equal(a0:N, a1:N) {
  }

  class <?::(T:Type)[]>> equal {}

  class <T::Array<E>> equal {}
  
  class equal<[T]>
  
  class equal {T}
  class equal::(T)

  class equal::String
  
  let x:String{} = {1, 2, 3, 4};
  
  class Array::String;
  
  def forall::(%T subtypes Iterator::%P) (in:T) {
  }
    
// ------------------------------------------------------------------------

Link-time code generation.

[Inject]
def construct(s:Someclass) {
}

var s:SomeClass = injector.create();

def <T> InjectAttribute : Attribute {
  def (target:T) {
    for i in 0 .. T.params.length {
      
    }
  }
  
  def getInstance(injector:Injector) -> T.result {
    
  }
}

namespace Numbers {
  protocol PrimitiveNumber<T> {
    let minVal:T;
    let maxVal:T;
  }
  
  protocol PrimitiveInt<T> : PrimitiveNumber<T> {}
  protocol PrimitiveFloat<T> : PrimitiveNumber<T> {}
  
  protocol_map PrimitiveInt<byte> {
    let minVal:byte = -128;
    let maxVal:byte = 127;
  }

  protocol_map PrimitiveInt<short> {
    let minVal:short = 0;
    let maxVal:short = 0x7fff;
  }
  
  // This 'extend' idea is not bad. The main problem is how to represent it
  // in the compiler. We don't want to modify the original class, nor do we
  // want to interfere with the lookup of the original class.
  //
  // The rules of 'extend' are as follows:
  //
  // 1) Only protocols can be added as base classes.
  // 2) Only static or final methods can be added as methods.
  // 3) Only static or final properties can be added as properties.
  // 4) Only constants can be added as member variables.
  //
  // In other words, nothing can be added that alters the runtime representation
  // of the object.
  //
  // In some ways, this is equivalent to saying:
  //
  // class byte : byte, PrimitiveInt {
  //   let minVal:byte = -128;
  //   let maxVal:byte = 127;
  // }
  //
  
  extend byte : PrimitiveInt {
  }

  extend short : PrimitiveInt {
  }

  //extend NativePointer<byte> {
  //}

  protocol_map PrimitiveInt<int> {}
  protocol_map PrimitiveInt<long> {}
  protocol_map PrimitiveInt<ubyte> {}
  protocol_map PrimitiveInt<ushort> {}
  protocol_map PrimitiveInt<uint> {}
  protocol_map PrimitiveInt<ulong> {}

  protocol_map PrimitiveFloat<float> {}
  protocol_map PrimitiveFloat<double> {}
  

  protocol PrimitiveNumber {}
}

// ------------------------------------------------------------------------

Compressed reflection information:

public class TypeExpression {
}

public class UnionType : TypeExpression {
}

public class AddressType : TypeExpression {
}

public class PointerType : TypeExpression {
}

public class FixedArrayType : TypeExpression {
}

public class TupleType : TypeExpression {
}

/** A member of a type */
class Member {
  enum Access : ubyte {
    PUBLIC,
    PRIVATE,
    PROTECTED,
  }
  
  enum MemberKind : ubyte {
    FIELD,
    PROPERTY,
    METHOD,
    CONSTRUCTOR,
  }
  
  @Flags enum Traits : ubyte {
    FINAL,
    ABSTRACT,
    STATIC,
  } 

  private def construct() {}

  /** The unqualified member name. */
  let name:String;
  
  /** The type of this member. */
  let memberType:Type;
  
  /** The class that declared this member, or null if it's a global function. */
  let declaringType:Type;

  /** What kind of member this is (FIELD, PROPERTY, METHOD, CONSTRUCTOR) */
  let kind:MemberKind;
  
  /** Accessibility of this member. */
  let access:Access;
  
  /** Various member flags. */
  let traits:Traits;

  /** Array of attributes for this member. */
  let attributes:Attribute[];
}

Member: 4 + 4 + 4 + 1 + 1 + 1 + 4 = 20.

Method: 20 + 4 + 4 + 4 + 4 = 36.

/** Description of a callable method. */
final class Method : Member {
  /** Array of type parameters. */
  let typeParams:Type[];

  /** The parameters of this method. */
  let params:Parameter[];
  
  /** The return type of the method. */
  let returnType:TypeDescriptor;

  /** A pointer to the function. */
  private let methodPointer:NativePointer[void];

  /** A pointer to a trampoline function that can take an array of objects and call
      the actual native method with the correct argument types.
      'obj': The object pointer, or null if it is a static or global function.
      'm': The native method pointer.
      'args': The argument list.
    */
  private let invoke:NativePointer[fn (obj:Object, m:NativePointer[void], args:Object[]) -> Object];

  /** Invoke the method on the specified object with the given arguments.
      TODO: Define exception types for bad argument types.
   */
  final def call(obj:Object, args:Object[]) -> Object {
    // TODO: Need a static function for attempt to call an abstract method.
    return invoke(obj, methodPointer, args);
  }
}


/** The metatype object - the class that describes a type. */
public class TypeDescriptor {
  enum TypeKind : ubyte {
    PRIMITIVE,
    CLASS,
    STRUCT,
    INTERFACE,
    ENUM,
    FUNCTION,
    TUPLE,
    UNION,
    NATIVE_POINTER,
    NATIVE_ARRAY,
    //NonType
  }

  @Flags  
  enum TypeTraits {
    ATTRIBUTE,
  }

  /** The TypeInfoBlock for this type. */  
  let typeInfo:NativePointer[TypeInfoBlock];
  
  /** The fully-qualified name of this type. */
  let name:String;
  
  /** What general kind of type this is (CLASS, STRUCT, etc.) */
  let typeKind:TypeKind;
  
  /** Pointer to this type's supertype, or null. */
  let supertype:TypeDescriptor /* or void */;
  
  /** Array of inherited interfaces. */
  let interfaces:TypeDescriptor[];
  
  /** Array of type parameters. */
  let typeParams:TypeDescriptor[];
  
  /** Array of associated attributes */
  let attributes:Attribute[];
  
  /** Array of field members. */
  let fields:Field[];
  
  /** Array of property members. */
  let properties:Property[];
  
  /** Array of constructor members. */
  let constructors:Method[];
  
  /** Array of methods. */
  let methods:Method[];

  /** Private constructor - types cannot be created by applications. */
  private def construct() {}
}
