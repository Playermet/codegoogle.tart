if let x:int = 1 {
}

while let x:int = b {
}

if let x:int = 1 {
}

// Wrong - y might be unassigned.
if (let x:int = 1) or (let y:int = 2) {
}

interface Iterator[%T] {
  def next -> T or Nothing;
}

interface Iterator#[List#[%T]] {
  def next -> T or Nothing;
}

var i:int = 0;
var l:List:int = List();

interface Iterator<>(List<>%T) {
  def next -> T or Nothing;
}

interface ContextHandler {
  def enter();
  def exit(e:Exception or Nothing) -> Exception or Nothing;

  def exit();
  def exit(e:Exception);
}

// Now we want to create an iterator adapter that can wrap any abstract
// iterator and create a polymorphic iterator. Here are the specs:
//
// The IterType is a concrete type.
// The IterType has a type parameter (T) representing the value type.
// The IterType conforms to the IteratorProtocol<T>.
// The IterType does not implement Iterator<T>.
// We create an PolymorphicIterator class which implements Iterator<T>.
// The PolymorphicIterator class is parameterized on T (the element type).
// The PolymorphicIterator class contains an IterType<T>.
// PolymorphicIterator must be a reference type, since only reference types
// can have virtual functions.

class PolymorphicIterator.[IteratorType <: AbstractIterator.[$T]]
    : Iterator.[T] {
  private let iter:IteratorType;
    
  def construct(iter:IteratorType) {
    self.iter = iter;
  }

  def next() -> T or Nothing {
    return iter.next();
  }
}

class PolymorphicIterator<IteratorType : Iterator<$T>> {
  private let iter:IteratorType;
    
  def construct(iter:IteratorType) {
    self.iter = iter;
  }
  
  def next() -> T or Nothing {
    return iter.next();
  }
}



//Array!String;

[template T:Type, IteratorType:Type]
[require IteratorType : IteratorProtocol[T]]
class PolymorphicIterator[IteratorType[T]] : Iterator[T] {
}

struct Vector4D[%T] require T issubtype Number {
  private var data:NativeArray<[T, 4]>;

  def x:T {
    get { return data[0]; }
    set { data[0] = value; }
  }

  def y:T {
    get { return data[1]; }
    set { data[1] = value; }
  }

  def z:T {
    get { return data[2]; }
    set { data[2] = value; }
  }

  def w:T {
    get { return data[3]; }
    set { data[3] = value; }
  }

  def [index:int]:T {
    get {
      IndexOutOfRangeError.when(index < 0 || index > 3);
      return data[index];
    }
    set {
      IndexOutOfRangeError.when(index < 0 || index > 3);
      data[index] = value;
    }
  }
}

struct Matrix[%T, %Rows:int, %Cols:int] require T issubtype Number {
  private var data:NativeArray<[T, Rows * Cols]>;

  def [row:int, col:int]:T {
    get {
      IndexOutOfRangeError.when(row < 0 || row >= Rows);
      IndexOutOfRangeError.when(col < 0 || col >= Cols);
      return data[row * Cols + col];
    }
    set {
      IndexOutOfRangeError.when(row < 0 || row >= Rows);
      IndexOutOfRangeError.when(col < 0 || col >= Cols);
      data[row * Cols + col] = value;
    }
  }
  
  def construct() {
    for i = 0; i < Rows * Cols; ++i {
      data[i] = 0;
    }
  }
}

typealias Matrix4f:Matrix<[float, 4, 4]>;
typealias Matrix4d:Matrix<[double, 4, 4]>;

class Transform {
  private var m:Matrix4d;
}
