if let x:int = 1 {
}

while let x:int = b {
}

if let x:int = 1 {
}

// Wrong - y might be unassigned.
if (let x:int = 1) or (let y:int = 2) {
}

var i:int = 0;
var l:List:int = List();

interface ContextHandler {
  def enter();
  def exit(e:Exception or Nothing) -> Exception or Nothing;

  def exit();
  def exit(e:Exception);
}

struct Vector4D[%T] require T issubtype Number {
  private var data:NativeArray<[T, 4]>;

  def x:T {
    get { return data[0]; }
    set { data[0] = value; }
  }

  def y:T {
    get { return data[1]; }
    set { data[1] = value; }
  }

  def z:T {
    get { return data[2]; }
    set { data[2] = value; }
  }

  def w:T {
    get { return data[3]; }
    set { data[3] = value; }
  }

  def [index:int]:T {
    get {
      IndexOutOfRangeError.when(index < 0 || index > 3);
      return data[index];
    }
    set {
      IndexOutOfRangeError.when(index < 0 || index > 3);
      data[index] = value;
    }
  }
}

struct Matrix[%T, %Rows:int, %Cols:int] require T issubtype Number {
  private var data:NativeArray<[T, Rows * Cols]>;

  def [row:int, col:int]:T {
    get {
      IndexOutOfRangeError.when(row < 0 || row >= Rows);
      IndexOutOfRangeError.when(col < 0 || col >= Cols);
      return data[row * Cols + col];
    }
    set {
      IndexOutOfRangeError.when(row < 0 || row >= Rows);
      IndexOutOfRangeError.when(col < 0 || col >= Cols);
      data[row * Cols + col] = value;
    }
  }
  
  def construct() {
    for i = 0; i < Rows * Cols; ++i {
      data[i] = 0;
    }
  }
}

typealias Matrix4f:Matrix<[float, 4, 4]>;
typealias Matrix4d:Matrix<[double, 4, 4]>;

class Transform {
  private var m:Matrix4d;
}


class DocParser {
public:
  enum Token {
    Token_End,
    Token_Paragraph,
    Token_Preformatted,
    Token_Indent,
    Token_Dedent,
    
  };

  DocParser(const std::string & docString);
  
  
};

class DocNode {
  enum NodeType {
    Section,
    Paragraph,
    Preformatted,
    ListItem,
    Definition,
    Link,
  };
  
  enum DefinitionType {
    Parameter,
    Return,
    Exception,
  }
};

class Paragraph {
};

class Doc {
public:
  const std::string & name() const;
  const std::string & qualifiedName() const;
private:
};

class ProgramElementDoc : public Doc {
public:
  const ASTDecl * decl() const { return decl_; }

private:
  const ASTDecl * decl_;
};

class ClassDoc : public ProgramElementDoc {
};

class ConstructorDoc : public ProgramElementDoc {
};

class FieldDoc : public ProgramElementDoc {
};

class PropertyDoc : public ProgramElementDoc {
};

class MethodDoc : public ProgramElementDoc {
};

class PackageDoc : public ProgramElementDoc {
};

class NamespaceDoc : public ProgramElementDoc {
};


depends "tart/core/String.tart"; 
depends "tart/core/Iterator.tart";

import tart.core.String = 1;
import tart.core.Iterator[char] = 2;

// Compiled module format
public final class StringBuilder : %2 {
  private var value:char[];
  private var _length:int;
  private def grow(amount:int);
  private static def insertionCount(inputLength:int, start:int, count:int) -> int;
  public def construct();
  public def construct(s:%1, start:int = 0, count:int = int.maxVal);
  public def construct(c:char[], start:int = 0, count:int = int.maxVal);
  public def length:int { get; }
  public def append(c:char);
  public def append(c:char[], start:int = 0, count:int = int.maxVal);
  public def append(s:%1, start:int = 0, count:int = int.maxVal);
  public def append(s:%2);
  public def insert(n:int, c:char);
  public def insert(n:int, c:char[], start:int = 0, count:int = int.maxVal);
  public def insert(n:int, s:String, start:int = 0, count:int = int.maxVal);
  public def insert(n:int, s:%2);
  public def remove(n:int);
  public def remove(n:int, count:int);
  public def clear();
}
