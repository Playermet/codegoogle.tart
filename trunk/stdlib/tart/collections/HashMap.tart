/** A quadratically-probed hash map. */
final class HashMap[%Key, %Value, %HashFn = Hashing.HashFn[Key]] : Map[Key, Value] {
  
  private {
    enum EntryState : uint8 {
      EMPTY,
      DELETED,
      OCCUPIED
    }
    
    struct Entry {
      var key:Key;
      var value:Value;
      var state:EntryState;
      
      def construct(key:Key, value:Value) {
        self.key = key;
        self.value = value;
        self.state = EntryState.OCCUPIED;
      }
    }
    
    var _data:Entry[];
    var _length:int32;
    let _hashFn:HashFn;

    def findEntry(key:Key) -> int {
	    if _data.length > 16 {
        let mask = _data.length - 1;
        var index = int(_hashFn.hash(key)) & mask;
        var probe = 1;
      
	      // First, see if the item is already in the table
	      while probe <= 4 {
	        let st = self._data[index].state;
	        return -1 if st == EntryState.EMPTY;
          return index if st == EntryState.OCCUPIED and self._data[index].key == key;
	        index = (index + probe) & mask;
	        probe += 1;
	      }
	      
	      return -1;
	    } else if _data.length > 0 {
	      for i = 0; i < _length; ++i {
	        if _data[i].key == key {
	          return i;
	        }
	      }
	
	      return -1;
	    } else {
	      return -1;
	    }
    }

    def rehash(oldItems:Entry[], oldLength:int, newLength:int) {
      let mask = newLength - 1;
      self._data = Entry[](newLength);
      for i = 0; i < oldLength; ++i {
        if oldItems[i].state == EntryState.OCCUPIED {
          let key = oldItems[i].key;
          var index = int(_hashFn.hash(key)) & mask;
          var probe = 1;
          // Rehashing presumes that all keys are already unique.
          while self._data[index].state == EntryState.OCCUPIED {
            index = (index + probe) & mask;
            probe += 1;
            if probe > 4 {
              // If it takes more than 4 probes, then expand the table again and
              // start the rehashing over.
              rehash(oldItems, oldLength, newLength * 2);
              return;
            }
          }
          
          _data[index] = Entry(key, oldItems[i].value);
        }
      }
    }
  }

  def construct() {
    self._data = Entry[](0);
    self._length = 0;
  }

  /** Access a value by key. */
  def [key:Key]:Value {
    get {
			var index:int = findEntry(key);
			if index < 0 {
			  //throw KeyNotFoundException();
			}

			return _data[index].value;
    }

    set { }
  }
  
  def length:int { get { return _length; } }

  def isEmpty:bool { get { return _length == 0; } }

  def contains(key:Key) -> bool {
    return false;
  }

  def clear() {
  }

  def iterate -> Iterator[(Key, Value)] {
    return EntryIterator(self);
  }

  def keys:Iterator[Key] { get { return KeyIterator(self); } }
  def values:Iterator[Value] { get { return ValueIterator(self); } }
  
  def add(entry:(Key, Value)) -> bool {
    return false;
  }

  def addAll(entries:(Key, Value)...) {
    addAll(entries);
  }

  def addAll(entries:Iterable[(Key, Value)]) {
    addAll(entries.iterate());
  }
    
  def addAll(entries:Iterator[(Key, Value)]) {
    for entry in entries {
      add(entry);
    }
  }

  def remove(key:Key) -> bool {
    return false;
  }
  
  def removeAll(keys:Key...) {
    removeAll(keys);
  }

  def removeAll(keys:Iterable[Key]) {
  }
  
  def removeAll(keys:Iterator[Key]) {
  }
  
  private class KeyIterator : Iterator[Key] {
    var _entries:Entry[];
    
    def construct(map:Map) {
    }

	  def next -> Key or void {
	    return;
	  }
  }
  
  private class ValueIterator : Iterator[Value] {
    var _entries:Entry[];

    def construct(map:Map) {
    }

	  def next -> Value or void {
	    return;
	  }
  }
  
  private class EntryIterator : Iterator[(Key, Value)] {
    var _entries:Entry[];

    def construct(map:Map) {
    }

	  def next -> (Key, Value) or void {
	    return;
	  }
  }
  
  // TODO: Add equals, computeHash (for immutable collections only).
}
