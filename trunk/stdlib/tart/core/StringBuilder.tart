/** A mutable, extensible string. */
 /* : public Iterable[char] */
public final class StringBuilder {
  private {
    var value:char[];
    var len:int;

    def grow(amount:int) {
      let newSize = self.len + amount;
      if value.length < newSize {
        let newValue = char[](newSize + newSize / 2 + 16);
        char[].copy(newValue, 0, value, 0, self.len);
      }

      self.len = newSize;
    }
    
    static def insertionCount(inputLength:int, start:int, count:int) -> int {
      Preconditions.checkIndex(inputLength >= 0);
      Preconditions.checkIndex(count >= 0);
      Preconditions.checkIndex(start >= 0);
      start = Math.min(start, inputLength);
      count = Math.min(count, inputLength - start);
      return count;
      //return start, count;
    }
  }

  def construct() {
    value = char[](0);
    self.len = 0;
  }

  def construct(s:String, start:int = 0, count:int = int.maxVal) {
    value = char[](0); // s.toArray()
    self.len = s.length;
  }

  def construct(c:char[], start:int = 0, count:int = int.maxVal) {
    value = char[](0); // s.toArray()
    self.len = c.length;
  }
  
  def length:int {
    get { return self.len; }
  }

  def append(c:char) {
    let n = self.len;
    grow(1);
    value[n] = c;
  }
  
  def append(c:char[], start:int = 0, count:int = int.maxVal) {
  }
  
  def append(s:String, start:int = 0, count:int = int.maxVal) {
  }
  
  def append(s:Iterator[char]) {
    insert(self.len, s);
  }
  
  def insert(n:int, c:char) {
  }
  
  def insert(n:int, c:char[], start:int = 0, count:int = int.maxVal) {
  }
  
  def insert(n:int, s:String, start:int = 0, count:int = int.maxVal) {
  }
  
  def insert(n:int, s:Iterator[char]) {
    classify s {
      as sequence:HasLength {
        grow(int(sequence.length));
        for c in s {
          value[self.len++] = c;
        }
      } else {
      }
    }

    //let n = self.length;
    //resize(n + s.length);
    //value[n] = c;
  }

  def remove(n:int) {
  }

  def remove(n:int, count:int) {
  }
  
  def clear() {
  }
}
