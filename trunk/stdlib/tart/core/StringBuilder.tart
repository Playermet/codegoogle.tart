/** A mutable, extensible string. */
 /* : public Iterable[char] */
public final class StringBuilder {
  private {
    var value:char[];
    var len:int;

    def grow(amount:int) {
      let newSize = self.len + amount;
      if value.length < newSize {
        let newValue = char[](newSize + newSize / 2 + 16);
        char[].copy(newValue, 0, value, 0, self.len);
      }

      self.len = newSize;
    }
  }

  def construct() {
    value = char[](0);
    self.len = 0;
  }

  def construct(s:String, start:int = 0, count:int = int.maxVal) {
    let chars = s.toCharArray();
    value = char[](0); // s.toArray()
    self.len = s.length;
  }

  def construct(c:char[], start:int = 0, count:int = int.maxVal) {
    value = char[](0); // s.toArray()
    self.len = c.length;
  }
  
  def length:int {
    get { return self.len; }
  }

  def append(c:char) {
    let n = self.len;
    grow(1);
    value[n] = c;
  }
  
  def append(c:char[], start:int = 0, count:int = int.maxVal) {
    insert(self.len, c, start, count);
  }
  
  def append(s:String, start:int = 0, count:int = int.maxVal) {
    append(s.toCharArray(), start, count);
  }
  
  def append(s:Iterator[char]) {
    insert(self.len, s);
  }
  
  def insert(insertPos:int, c:char) {
  }
  
  def insert(insertPos:int, c:char[], start:int = 0, count:int = int.maxVal) {
    Preconditions.checkIndex(insertPos >= 0 and insertPos <= self.len);
    Preconditions.checkIndex(count >= 0);
    Preconditions.checkIndex(start >= 0);
    if start < c.length {
      count = Math.min(count, c.length - start);
      if count > 0 {
        grow(count);
        char[].copy(value, insertPos, self.value, insertPos + count, self.len - insertPos);
        char[].copy(value, insertPos, c, start, count);
        self.len += count;
      }
    }
  }
  
  def insert(insertPos:int, s:String, start:int = 0, count:int = int.maxVal) {
    insert(insertPos, s.toCharArray(), start, count);
  }
  
  def insert(insertPos:int, s:Iterator[char]) {
    classify s {
      as sequence:HasLength {
        grow(int(sequence.length));
        for c in s {
          value[self.len++] = c;
        }
      } else {
      }
    }

    //let n = self.length;
    //resize(n + s.length);
    //value[n] = c;
  }

  def remove(n:int) {
    remove(n, 1);
  }

  def remove(n:int, count:int) {
  }
  
  def clear() {
    self.len = 0;
  }
  
  def toString() -> String {
    return String(value, 0, self.len);
  }  
}
