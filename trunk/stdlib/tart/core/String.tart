import tart.core.Memory.zeroPtr;
import tart.core.Memory.addressOf;

/** The built-in string class. Strings are immutable. */
 /* : public Iterable[char] */
public final class String {

  private {
    /** The length of the string, in bytes. */
    var len:int;

    /** For strings which are slices, this points to the original string.
        For non-slice strings, or strings which refer to constant string
        literals, this points to 'self'. */
    var source:String;
    
    /** The pointer to the starting byte. */
    var start:NativePointer[NativeArray[ubyte, 0]];
    
    /** For non-slice strings, this is the array of bytes immediately
        following the string instance in memory. */
    var data:NativeArray[ubyte, 0];

    /** Custom allocation function for strings. */
    //[RequireFeature]
    static def alloc(len:int) -> String {
      // The 'offsetof' trick for calculating the size.
      let s:String = __pvalloc(zeroPtr[String]().data[len]);
      s.len = len;
      s.source = s;
      s.start = addressOf(s.data);
      return s;
    }
  }

  /** Construct a string from a byte array. */
  static def create(bytes:ubyte[]) -> String {
    let self = alloc(bytes.length);
    // TODO: Test
    // TODO: Need for array copy to work with non-native arrays I guess.
    for i = 0; i < self.len; i++ {
      self.data[i] = bytes[i];
    }
    return self;
  }

  /** Construct a string from a native byte array. */
  @LinkageName("String_create")
  static def create(bytes:NativePointer[NativeArray[ubyte, 0]], length:int) -> String {
    let self = alloc(length);
    // TODO: Test
    // TODO: Need for array copy to work with non-native arrays I guess.
    for i = 0; i < self.len; i++ {
      self.data[i] = bytes[i];
    }
    return self;
  }

  /** 'true' if this is an empty string. */
  def isEmpty:bool {
    get { return self.len == 0; }
  }
  
  /** The length of the string in bytes. */
  def length:int { get { return self.len; } } 
  
  /** The length of the string in characters. */
  def charLength:int {
    get {
      var result:int = 0;
      var index:int = 0;
      while index < self.len {
        let c = self.data[index];
        if c < 0x80 {
          index += 1;
        } else if c < 0xc0 {
          // Invalid unicode char
          break;
        } else if c < 0xe0 {
          index += 2;
        } else if c < 0xf0 {
          index += 3;
        } else if c < 0xf5 {
          index += 4;
        } else {
          // Invalid unicode char, 
          break;
        }

        ++result;
      }
      
      if index != self.len {
      }
      
      return result;
    }
  }
  
  /** Coerce a String to a String simply returns 'self'. */
  def toCharArray -> char[] {
    let result = char[](self.charLength);
    var index:int = 0;
    var pos:int = 0;
    while index < self.len {
      let b = self.data[index];
      var charVal:uint = 0;
      if b < 0x80 {
        index += 1;
        charVal = b;
      } else if b < 0xc0 {
        // Invalid unicode char
        break;
      } else if b < 0xe0 {
        charVal = (uint(b & 0x3f) << 6)
                | (self.data[index + 1] & 0x7f);
        index += 2;
      } else if b < 0xf0 {
        charVal = (uint(b & 0x1f) << 12)
                | (uint(self.data[index + 1] & 0x7f) << 6)
                | (self.data[index + 2] & 0x7f);
        index += 3;
      } else if b < 0xf5 {
        charVal = (uint(b & 0x0f) << 18)
                | (uint(self.data[index + 1] & 0x7f) << 12)
                | (uint(self.data[index + 2] & 0x7f) << 6)
                | (self.data[index + 3] & 0x7f);
        index += 4;
      } else {
        // Invalid unicode char, 
        break;
      }

      result[pos++] = charVal;
    }

    return result;
  }

  /** 'true' if 's' is equal to to this string. */
  def equals(s:String) -> bool {
    return false if self.len != s.len;
    for i = 0; i < self.len; i++ {
      return false if self.start[i] != s.start[i];
    }
    
    return true;
  }

  /** The index operator. */
  def [index:int]:ubyte {
    get {
      //Preconditions.verify[IndexOutOfRangeError](index < 0 or index >= len);
      return self.data[index];
    }
  }

  /** Return this string as a memory buffer. */
  //def asBuffer -> Memory.Buffer[ubyte] {
  //  return Memory.Buffer(self, addressOf(start[0]), addressOf(start[len]));
  //}

  /** Coerce a String to a String simply returns 'self'. */
  def toString -> String {
    return self;
  }

  static def concat(s:String...) -> String {
    let count = s.length;
    var length = 0;
    for i = 0; i < count; ++i {
      length += s[i].len;
    }
    
    let result = alloc(length);
    var index = 0;
    for i = 0; i < count; ++i {
      let src = s[i];
      //Memory.arrayCopy(result.data, index, src.data, 0, src.len);
      //index += src.len;
      for j = 0; j < src.len; ++j {
        result.data[index++] = src.data[j];
      }
    }

    return result;
  }
}

/** Equality comparison operator for strings. */
public def infixEQ(s1:String, s2:String) -> bool {
  return s1.equals(s2);
}
