import tart.core.Memory.zeroPtr;
import tart.core.Memory.addressOf;

/** The built-in string class. Strings are immutable. */
 /* : public Iterable[char] */
public final class String {
  /** The length of the string, in bytes. */
  readonly var length:int;

  private {
    /** For strings which are slices, this points to the original string.
        For non-slice strings, or strings which refer to constant string
        literals, this points to 'self'. */
    var source:String;
    
    /** The pointer to the starting byte. */
    var start:NativePointer[NativeArray[ubyte, 0]];
    
    /** For non-slice strings, this is the array of bytes immediately
        following the string instance in memory. */
    var data:NativeArray[ubyte, 0];

    /** Custom allocation function for strings. */
    //[RequireFeature]
    static def alloc(length:int) {
      // The 'offsetof' trick for calculating the size.
      let s:String = __pvalloc(zeroPtr[String]().data[length]);
      s.length = length;
      s.source = s;
      s.start = addressOf(s.data);
      return s;
    }
  }

  /** Construct a string from a byte array. */
  static def create(bytes:ubyte[]) -> String {
    let self = alloc(bytes.length);
    // TODO: Test
    // TODO: Need for array copy to work with non-native arrays I guess.
    for i = 0; i < self.length; i++ {
      self.data[i] = bytes[i];
    }
    return self;
  }

  /** Construct a string from a native byte array. */
  @LinkageName("String_create")
  static def create(bytes:NativePointer[NativeArray[ubyte, 0]], length:int) -> String {
    let self = alloc(length);
    // TODO: Test
    // TODO: Need for array copy to work with non-native arrays I guess.
    for i = 0; i < self.length; i++ {
      self.data[i] = bytes[i];
    }
    return self;
  }

  /** 'true' if this is an empty string. */
  def isEmpty:bool {
    get { return self.length == 0; }
  }
  
  /** 'true' if 's' is equal to to this string. */
  def equals(s:String) -> bool {
    return false if self.length != s.length;
    for i = 0; i < self.length; i++ {
      return false if self.start[i] != s.start[i];
    }
    
    return true;
  }

  /** The index operator. */
  def [index:int]:ubyte {
    get {
      //IndexOutOfRangeError.when(index < 0 or index >= length);
      return self.data[index];
    }
  }

  /** Return this string as a memory buffer. */
  //def toBuffer() -> MemoryBuffer<ubyte> {
  //  return MemoryBuffer(self, addressOf(start[0]), addressOf(start[length]));
  //}

  /** Coerce a String to a String simply returns 'self'. */
  def toString -> String {
    return self;
  }

  /*static def concat(s:String...) {
    let result = alloc(s0.length + s1.length);
    Memory.arrayCopy(result.data, 0, s0.data, 0, s0.length);
    Memory.arrayCopy(result.data, s0.length, s1.data, 0, s1.length);
    return result;
  }*/
}

/** Equality comparison operator for strings. */
public def infixEQ(s1:String, s2:String) -> bool {
  return s1.equals(s2);
}
