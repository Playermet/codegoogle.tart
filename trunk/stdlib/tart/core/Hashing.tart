import tart.core.Memory.Address;

/** Various useful hash functions. */
namespace Hashing {
  // Hash functions based on MurmurHash 2.0 by Austin Appleby.
  
  /** Hash a single 32-bit integer. */
  def hash(value:uint32) -> uint32 {
    return murmurHash(value);
  }
  
  /** Hash a single 64-bit integer. */
  def hash(value:uint64) -> uint64 {
    return murmurHash(value);
  }
  
  /** Hash a pointer. */
  def hash[%T](value:Address[T]) -> uint32 {
    return murmurHash(Memory.ptrToPtr[T, void](value));
  }
  
  let M32:uint32 = 0x5bd1e995;
  let M64:uint64 = 0xc6a4a7935bd1e995;
  
  /** Hash a single 32-bit integer. */
  def murmurHash(key:uint32, seed:uint32 = 0) -> uint32 {
    var h:uint32 = seed ^ 1;
    key *= M32; 
    key ^= key >> 24; 
    key *= M32; 
    
    h *= M32;
    h ^= key;

    h ^= h >> 13;
    h *= M32;
    h ^= h >> 15;

    return h;
  }

  /** Hash a single 64-bit integer. */
  def murmurHash(key:uint64, seed:uint64 = 0) -> uint64 {
    let R:uint64 = 47;

    var h:uint64 = seed ^ M64;
    key *= M64; 
    key ^= key >> R; 
    key *= M64; 
    
    h ^= key;
    h *= M64; 

    h ^= h >> R;
    h *= M64;
    h ^= h >> R;

    return h;
  }

  /** Hash a pointer. */
  def murmurHash(key:Address[void]) -> uint32 {
    return murmurHash(Memory.ptrToInt(key));
  }

  /** Hash a byte buffer segment. */
  def murmurHash(key:Address[ubyte], length:int, seed:uint32 = 0) -> uint32 {
    //start = Math.min(start, key.length);
    //count = Math.min(count, key.length - start);
    

    //var align:uint32 = start & 3;
    return 0;
  }

  /** An incremental hasher. */
  struct Hasher {
    private {
      var hash:uint32;
      var tail:uint32;
      var count:uint32;
      var size:uint32;
    }

    def construct(seed:uint32 = 0) {
      hash = seed;
      tail = count = size = 0;
    }
  }
}
