import tart.reflect.Type;
import tart.annex.Nonreflective;

/** All objects contain a pointer to a TypeInfoBlock, which contains the
    pointer to the type object and the method table.
 */
@Nonreflective struct TypeInfoBlock {
  /** Reference to the type object for this type. */
  readonly var type:Type;

  /** The fully-qualified name of this type. */
  readonly var name:String;

  /** List of all types (classes and interfaces) that this type can be cast to.
      A null pointer terminates the list. */
  readonly var bases:__Address[__Pointer[TypeInfoBlock]];

  /** Compiler-generated function to lookup the specified interface method. */
  readonly var idispatch:static fn(interfaceType:__Pointer[TypeInfoBlock], methodIndex:int) -> __Pointer[void];

  /** Compiler-generated table of class methods. */
  readonly var methodTable:NativeArray[__Pointer[void], 0];

  /** Method to test whether a reference to an object of the type represented
      by this TIB can be legally cast to a reference to type 'toType'. Used
      by the compiler to do 'isa', 'as' and 'catch' tests. */
  public final def hasBase(toType:__Pointer[TypeInfoBlock]) -> bool {
    return true if Memory.addressOf(self) is toType;
    var i = 0;
    while let base:__Pointer[TypeInfoBlock] = self.bases[i++] {
      return true if base is toType;
    }

    return false;
  }

  /** Throw an InvalidTypecastError. Convenience function used by the compiler. */
  public static def typecastError() {
    throw TypecastException();
  }
}
