import tart.reflect.TypeDescriptor;

/** All objects contain a pointer to a TypeInfoBlock, which contains the
    pointer to the type object and the method table.
 */
struct TypeInfoBlock {
  /** Reference to the type object for this type. */
  readonly var type:TypeDescriptor;

  /** List of all types (classes and interfaces) that this type can be cast to.
      A null pointer terminates the list. */
  readonly var bases:__Address[NativePointer[TypeInfoBlock]];

  /** Compiler-generated function to lookup the specified interface method. */
  readonly var idispatch:fn(interfaceType:NativePointer[TypeInfoBlock], methodIndex:int) -> NativePointer[void];

  /** Compiler-generated table of class methods. */
  readonly var methodTable:NativeArray[NativePointer[void], 0];

  /** Method to test whether a reference to an object of the type represented
      by this TIB can be legally cast to a reference to type 'toType'. Used
      by the compiler to do 'isa', 'as' and 'catch' tests. */
  public final def hasBase(toType:NativePointer[TypeInfoBlock]) -> bool {
    return true if Memory.addressOf(self) is toType;
    var i = 0;
    while let base:NativePointer[TypeInfoBlock] = self.bases[i++] {
      return true if base is toType;
    }

    return false;
  }

  /** Throw an InvalidTypecastError. Convenience function used by the compiler. */
  public static def typecastError() {
    throw TypecastException();
  }
}
