import tart.core.Memory.zeroPtr;
import tart.core.Memory.addressOf;
import tart.core.Memory.ptrDiff;
import tart.core.Memory.Address;
import tart.core.Math.min;

/** Built-in array class */
public final class Array[%ElementType] : Iterable[ElementType] {
  private {
    var _length:intp;
    var _data:NativeArray[ElementType, 0];

    /** Array allocator function */
    static def alloc(length:intp) -> Array {
      let self:Array =  __pvalloc(zeroPtr[Array[ElementType]]()._data[length]);
      self._length = length;
      return self;
    }

    //def asBuffer() {
    //  return MemoryBuffer.<ElementType>(self, addressOf(self.data[0]), end);
    //}

    // Static empty array singleton.
    static var emptyArray:Array = [];
  }

  /** Construct an array of a given length */
  static def create(length:intp) -> Array {
    Preconditions.checkArgument(length >= 0);
    if (length == 0) {
      return emptyArray;
    }

    let self:Array = alloc(length);
    // TODO: Need to initialize the array elements to default values.
    // Memory.initToDefaultValues(addressOf(data[0]), end);
    return self;
  }

  /** Static factory function which takes advantage of the built-in behavior of
      variadic parameters to build an Array. */
  static def of(elements:ElementType...) -> Array {
    return elements;
  }

  /** True if the array is zero length. */
  def isEmpty:bool {
    get { return self._length == 0; }
  }

  /** The length of the array. */
  def length:intp {
    get { return _length; }
  }

  @Unsafe def data:Address[ElementType] { get { return addressOf(_data[0]); } }
  @Unsafe def elementAddress(offset:int32) -> Address[ElementType] {
    return addressOf(_data[offset]);
  }
  @Unsafe def elementAddress(offset:int64) -> Address[ElementType] {
    return addressOf(_data[offset]);
  }

  /** Array element access. */
  def [index:intp]:ElementType {
    get {
      Preconditions.checkIndex(index >= 0 and index < _length);
      return self._data[index];
    }
    set {
      Preconditions.checkArgument(index >= 0 and index < _length);
      self._data[index] = value;
    }
  }

  /** Make a copy of this array. */  
  def copy() -> Array {
    let result = Array(self._length);
    Memory.arrayCopy(addressOf(result._data[0]), addressOf(self._data[0]), self._length);
    return result;
  }

  /** Iterate over the elements of the array. */
  def iterate -> Iterator[ElementType] {
    return ArrayIterator(self);
  }

  /** Copy 'count' elements, starting from offset 'srcOffset' in array 'src', to offset
      'dstOffset' in array 'dst'.
   */  
  static def copyElements(dst:Array, dstOffset:intp, src:Array, srcOffset:intp, count:intp) {
    Preconditions.checkIndex(count >= 0);
    Preconditions.checkIndex(dstOffset >= 0 and dstOffset <= dst._length);
    Preconditions.checkIndex(srcOffset >= 0 and srcOffset <= src._length);
    count = min(count, dst._length - dstOffset, src._length - srcOffset);
    if count > 0 {
      Memory.arrayMove(addressOf(dst._data[dstOffset]), addressOf(src._data[srcOffset]), count);
    }
  }

  private final class ArrayIterator : Iterator[ElementType], HasLength {
    private var array:Array;
    private var index:intp;
    
    def construct(array:Array) {
      self.array = array;
      self.index = 0;
    }
    
    def next() -> ElementType or void {
      if (self.index < self.array._length) {
        return self.array._data[self.index++];
      } else {
        return;
      }
    }

    def length:long { get { return array._length; } }
  }
}
