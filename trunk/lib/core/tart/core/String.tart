import tart.core.Memory.zeroPtr;
import tart.core.Memory.addressOf;
import tart.core.Memory.Address;
import tart.text.encodings.Codecs;

/** The built-in string class. Strings are immutable. */
public final class String : Iterable[char] {
  private {
    /** The length of the string, in bytes. */
    var _size:int32;

    /** For strings which are slices, this points to the original string.
        For non-slice strings, or strings which refer to constant string
        literals, this points to 'self'. */
    var source:String;
    
    /** The pointer to the starting byte. */
    var start:Address[ubyte];
    
    /** For non-slice strings, this is the array of bytes immediately
        following the string instance in memory. */
    var data:NativeArray[ubyte, 0];

    /** Custom allocation function for strings. */
    static def alloc(len:int32) -> String {
      // The 'offsetof' trick for calculating the size.
      let s:String = __pvalloc(zeroPtr[String]().data[len]);
      s._size = len;
      s.source = s;
      s.start = addressOf(s.data[0]);
      return s;
    }
  }

  /** Construct a string from a byte array.
      Parameters:
        bytes: The byte array.
   */
  static def create(bytes:ubyte[]) -> String {
    let self = alloc(int32(bytes.size));
    Memory.arrayCopy(addressOf(self.data[0]), addressOf(bytes.data[0]), bytes.size);
    return self;
  }

  /** Construct a string from a subrange of a byte array.
      Parameters:
        bytes: The byte array.
        start: The starting index within the byte array.
        count: The number of bytes to use in constructing the string. Will be clamped
            to the end of the string if there are fewer than 'count' bytes following 'start'.
   */
  static def create(bytes:ubyte[], start:int32, count:int32) -> String {
    Preconditions.checkIndex(start >= 0);
    Preconditions.checkArgument(count >= 0);
    start = Math.min(start, int32(bytes.size));
    count = Math.min(count, int32(bytes.size) - start);
    let self = alloc(count);
    Memory.arrayCopy(addressOf(self.data[0]), addressOf(bytes.data[0]), count);
    return self;
  }

  /** Construct a string from a char array.
      Parameters:
        chars: The character array.
        start: The starting index within the character array.
        count: The number of characters to use in constructing the string. Will be clamped
            to the end of the string if there are fewer than 'count' characters following 'start'.
   */
  static def create(chars:char[], start:int32 = 0, count:int32 = int32.maxVal) -> String {
    let length = Codecs.UTF_8.encodedLength(chars, start, count);
    let self = alloc(int32(length));
    Codecs.UTF_8.encodeRaw(addressOf(self.data[0]), length, addressOf(chars.data[0]), count);
    return self;
  }

  /** Construct a string from a native byte array. */
  @LinkageName("String_create")
  static def create(bytes:Address[ubyte], length:int32) -> String {
    let self = alloc(length);
    Memory.arrayCopy(addressOf(self.data[0]), addressOf(bytes[0]), length);
    return self;
  }

  /** Implicitly convert values to String types. */
  static def create[%T] (value:T) -> String { return "<??>"; }
  static def create[%T <: HasToString] (value:T) -> String { return value.toString(); }
  static def create(value:Object) -> String { return value.toString(); }

  /** 'true' if this is an empty string. */
  def isEmpty:bool {
    get { return self._size == 0; }
  }
  
  /** The length of the string in bytes. */
  def size:int32 { get { return self._size; } } 

  /** Return true if this string starts with the substring 's'. */  
  def startsWith(s:String) -> bool {
    return false if s.size > self._size;
    for i:int32 = 0; i < s.size; ++i {
      return false if s[i] != self.data[i];
    }
      
    return true;
  }
  
  /** Return true if this string ends with the substring 's'. */  
  def endsWith(s:String) -> bool {
    return false if s.size > self._size;
    let offset = self.size - s.size;
    for i:int32 = 0; i < s.size; ++i {
      return false if s[i] != self.data[i + offset];
    }
      
    return true;
  }
  
  /** The length of the string in characters.
      Parameters:
        start: The starting byte index of the substring to measure.
        count: The length, in bytes, of the substring to measure.
   */
  def charLength(start:int32 = 0, count:int32 = int32.maxVal) -> int32 {
    Preconditions.checkIndex(start >= 0 and count >= 0);
    start = Math.min(start, self._size);
    count = Math.min(count, self._size - start);
    return int32(Codecs.UTF_8.decodedLengthRaw(addressOf(self.data[start]), count));
  }
  
  /** Convert this string to a character array.
      Parameters:
        start: The starting byte index of the substring to convert.
        count: The length, in bytes, of the substring to convert.
   */
  def toCharArray(start:int32 = 0, count:int32 = int32.maxVal) -> char[] {
    Preconditions.checkIndex(start >= 0 and count >= 0);
    start = Math.min(start, self._size);
    count = Math.min(count, self._size - start);
    let charCount = self.charLength(start, count);
    let result = char[](charCount);
    Codecs.UTF_8.decodeRaw(
        addressOf(result.data[0]), charCount, addressOf(self.data[start]), count);
    return result;
  }

  /** 'true' if 's' is equal to to this string. */
  def equals(s:String) -> bool {
    return false if self._size != s._size;
    for i = 0; i < self._size; i++ {
      return false if self.start[i] != s.start[i];
    }
    
    return true;
  }

  /** The index operator. */
  def [index:int]:ubyte {
    get {
      //Preconditions.verify[IndexOutOfRangeError](index < 0 or index >= len);
      return self.data[index];
    }
  }

  /** Return this string as a memory buffer. */
  //def asBuffer -> Memory.Buffer[ubyte] {
  //  return Memory.Buffer(self, addressOf(start[0]), addressOf(start[len]));
  //}

  /** Coerce a String to a String simply returns 'self'. */
  override toString -> String {
    return self;
  }

  static def concat(s:String...) -> String {
    return concat(s);
  }
  
  static def format(formatString:String, args:Object...) -> String {
    return formatString.format(args);
  }

  def format(args:Object...) -> String {
    return format(args);
  }

  def format(args:Object[]) -> String {
    return StringFormatter(self, args).build();
  }

  static def concat(s:String[]) -> String {
    let count = s.size;
    var length:int32 = 0;
    for i = 0; i < count; ++i {
      length += s[i]._size;
    }
    
    let result = alloc(length);
    var index = 0;
    for i = 0; i < count; ++i {
      let src = s[i];
      Memory.arrayCopy(addressOf(result.data[index]), addressOf(src.data[0]), src._size);
      index += src._size;
    }

    return result;
  }

  /** A protocol for types that have a 'toString' method. */
  protocol HasToString {
    def toString() -> String;
  }

  /** Implicitly convert values to String types. */
//  static def coerce[%T] (value:T) -> String { return "<??>"; }
//  static def coerce[%T <: HasToString] (value:T) -> String { return value.toString(); }
//  static def coerce(value:Object) -> String { return value.toString(); }

  /** Return an immutable buffer representation of this string's data. */
  def asBuffer() -> Memory.Buffer[ubyte] {
    return Memory.Buffer[ubyte](self, start, addressOf(start[self._size]));
  }

  /** Compute a hash value for this string. */
  override computeHash -> uint64 {
    return Hashing.hash(asBuffer());
  }

	/** Iterate over the characters in this string. */  
  def iterate -> Iterator[char] {
    return StringIterator(self);
  }
  
  /** String iterator class. */
  private final class StringIterator : Iterator[char] {
    private {
      let str:String;
      var index:int;
    }
    
    def construct(str:String) {
      self.str = str;
      self.index = 0;
    }
    
    def next -> char or void {
      var charVal:char;
      if index < str._size {
	      charVal, index = Codecs.UTF_8.decodeOne(str.start, index, str._size);
  	    return charVal;
      } else {
        return;
      }
    }
  }
}

/** Equality comparison operator for strings. */
public def infixEQ(s1:String, s2:String) -> bool {
  return s1.equals(s2);
}
