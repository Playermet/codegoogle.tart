import tart.core.Memory.Address;
import tart.collections.ArrayList;
import tart.collections.ImmutableList;

/** The compressed and encoded reflection data for a type, namespace or module. */
@Reflection(Reflection.Detail.NONE) final class ReflectionMetadata {
  /** Tags used to represent the start of a definition. */
	enum DefnTag : uint8 {
    SCOPE_END = 0,    // End of scope
    MODULE,           // A module definition
    NAMESPACE,        // A namespace definition
    CLASS,            // A class definition
    STRUCT,           // A struct definition
    INTERFACE,        // An interface definitions
    PROTOCOL,         // A protocol definition
    METHOD,           // A method definition
    UNDEF,            // A method un-definition
    OVERRIDE,         // A method override
    CONSTRUCTOR,      // A constructor definition
    MACRO,            // A macro definition
    INDEXER,          // An indexer definition
    PROPERTY,         // A property definition
    VARIABLE,         // A variable definition
    LET,              // An immutable constant
    ENUM,             // An enumeration type
    IMPORT,           // An import definition
    TYPEALIAS,        // A type alias
    PARAM,            // A parameter definition within a method
    TYPE_PARAM,       // A template parameter definition
    ATTRIBUTE,				// An attribute (applies to current scope).
  
    // Modifier tags which affect the containing scope.
  
    MOD_ATTRIBUTE = 32,// Modifies a declaration to add an attribute.
    //MOD_STATIC,        // Modifies a declaration to have static storage class
    //MOD_FINAL,         // Modifies a class or method to be final
    //MOD_ABSTRACT,      // Modifies a class or method to be abstract
    MOD_VARIADIC,      // Modifies a parameter to be variadic
    MOD_KEYWORD_ONLY,  // Modifies a parameter to be keyword-only
	}
	
	@Flags enum DefnFlags : uint8 {
	  STATIC,
	  ABSTRACT,
	  FINAL,
	  PROTECTED,
	  PRIVATE,
	}
	
	/** Tags used to define types. */
  enum TypeTag : uint8 {
  	VOID = 0,
    BOOL,
    CHAR,
    INT8,
    INT16,
    INT32,
    INT64,
    UINT8,
    UINT16,
    UINT32,
    UINT64,
    FLOAT,
    DOUBLE,
    NULL,
    UNSIZED_INT,

    // Derived types
  
    FUNCTION = 16,   // Function type (flags, return-type, params...)
    FUNCTION_STATIC, // Function with no 'self' param.
    BOUND_METHOD,    // Bound method (flags, return-type, params...)
    TUPLE,           // Tuple table index follows
    UNION,           // Tuple table index follows
    UNIT,            // ??
    ADDRESS,         // Type table index follows
    NARRAY,          // Type table index and length follows
    TYPEVAR,         // variable name index follows (? should be index ?)
    TYPELITERAL,     // Literal reference to a type
    VARIADIC,        // Type follows
  
    // Indirect type tags - tag byte is followed by varint table index.
  
    COMPOSITE = 32,   // Followed by index into composite type table.
    DERIVED = 33,     // Followed by index into derived type table.
    ENUM = 34,        // Followed by index into enum type table.
  
    // Immediate-mode tags, tag data is in low bits of tag byte.
  
    ENUM_IMM = 48,       // Low 4 bits are index into enum type table.
    COMPOSITE_IMM = 64,  // Low 6 bits are index into composite type table.
    DERIVED_IMM = 128,   // Low 7 bits are index into derived type table.
  }

  enum SectionTag : uint8 {
    END = 0,
	  TYPE_PARAMS = 1,
  	BASE_CLASS = 2,
  	INTERFACES = 3,
  	ATTRIBUTES = 4,
  	INNER_TYPES = 5,
  	NAMESPACES = 6,
  	FIELDS = 7,
  	CONSTRUCTORS = 8,
  	METHODS = 9,
  	PROPERTIES = 10,
  }
  
  typealias InvokeFn:static fn (func:Address[void], obj:Address[void], args:Object[]) -> Object;

  private {
    var _value:optional Object;
  	var _names:NameTable;
  	var _strmTypeRefs:Address[ubyte];
  	var _strmDefns:Address[ubyte];
    var _nameIndex:int16;
    var _defnType:DefnTag;
    var _traits:Member.Traits;
  	var _derivedTypes:optional Type[];
  	var _compositeTypes:Address[Address[TypeInfoBlock]];
  	var _enumTypes:Address[Address[EnumInfoBlock]];
  	var _invokeFns:Address[InvokeFn];
  	// field offsets
  	// methods.
  	// globals
  }
  
  undef construct;

  def names:NameTable { get { return _names; } }

  def qualifiedName:String { get { return _names.getQualifiedName(_nameIndex); } }
  def scopeName:String { get { return _names.getScopeName(_nameIndex); } }
  def localName:String { get { return _names.getLocalName(_nameIndex); } }
  
  def derivedTypes:Type[] { get { return lazyEval(_derivedTypes, decodeDerivedTypes()); } }

  static def getCompositeType(tib:Address[TypeInfoBlock]) -> CompositeType {
    var meta = tib._meta;
    if meta is null {
      // TODO - throw an exception?
    }
    
    if meta._value is not null {
      return typecast[CompositeType](meta._value);
    }
    
    var type:CompositeType;
		switch (meta._defnType) {
		  case CLASS { type = CompositeType(Type.TypeKind.CLASS, tib); }
		  case STRUCT { type = CompositeType(Type.TypeKind.STRUCT, tib); }
		  case INTERFACE { type = CompositeType(Type.TypeKind.INTERFACE, tib); }
		  case PROTOCOL { type = CompositeType(Type.TypeKind.PROTOCOL, tib); }
		  else { throw ArgumentError("Invalid reflection metadata for type"); }
		}
		
		meta._value = type;
		return type;
  }

  // readModule
  // readType
  // readNamespace
  
  def readBaseClass -> optional CompositeType {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.BASE_CLASS);
    if length != 0 {
	  	return typecast[CompositeType](decodeType(decoder));
    }
    
    return null;
  }

  def readInterfaces() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.INTERFACES);
    if length != 0 {
    	Debug.writeLn("Length of interfaces section = ", length.toString());
    }
  }

  def readTypeParams() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.TYPE_PARAMS);
    if length != 0 {
    	Debug.writeLn("Length of type params section = ", length.toString());
    }
  }

  def readFields() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.FIELDS);
    if length != 0 {
    	Debug.writeLn("Length of field section = ", length.toString());
    }
  }

  def readConstructors() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.CONSTRUCTORS);
    if length != 0 {
    	Debug.writeLn("Length of constructor section = ", length.toString());
    }
  }

  def readMethods(selfType:Type) {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.METHODS);
    if length != 0 {
    	Debug.writeLn("Length of method section = ", length.toString());
    	let endPos = decoder.position + length;
    	while decoder.position < endPos {
		  	decodeMethod(decoder, selfType);
		  	break;
    	}
    }
  }

  private def decodeMethod(decoder:StreamDecoder, selfType:Type) {
    let tag = DefnTag(decoder.readByte());
    let flags = DefnFlags(decoder.readByte());
    let name = decodeFieldName(decoder);
    let methodType = decodeType(decoder);

    Debug.writeLn("decodeMethod: ", name);

		var kind:Member.MemberKind = Member.MemberKind.METHOD;
    switch tag {
      case METHOD {
      }
      
  	  case UNDEF {
  	  }
  	  
    	case OVERRIDE {
    	}

    	case CONSTRUCTOR {
    	  kind = Member.MemberKind.CONSTRUCTOR;
    	}

    	case MACRO {
    	}
    	
    	else {
    	  throw DecodingError("Invalid method tag: ", tag.toString());
    	}
    }

    repeat {
      let tag = DefnTag(decoder.readByte());
      switch tag {
        case SCOPE_END {
          break;
        }
        
        case ATTRIBUTE {
        }
        
        case PARAM {
			    let paramName = decodeFieldName(decoder);
        }

        else {
    	  	throw DecodingError("Invalid parameter tag: ", tag.toString());
        }
      }
    }
  }

  private def decodeDerivedTypes() -> Type[] {
    let decoder = StreamDecoder(_strmTypeRefs);
    let count = decoder.readVarInt();
    Debug.writeLn("Number of derived types: ", String(count));
    return Type[](1);
  }

  private def decodeTypeList(decoder:StreamDecoder) -> Type[] {
    let count = decoder.readVarInt();
    let result = Type[](count);
    for i = 0; i < count; ++i {
      let memberType = decodeType(decoder);
      result[i] = memberType;
    }
    
    return result;
  }

  private def decodeType(decoder:StreamDecoder) -> Type {
    let typeId = TypeTag(decoder.readByte());
    switch typeId {
      case VOID 	{ return PrimitiveType.VOID; }
      case BOOL 	{ return PrimitiveType.BOOL; }
      case CHAR 	{ return PrimitiveType.CHAR; }
      case INT8 	{ return PrimitiveType.INT8; }
      case INT16 	{ return PrimitiveType.INT16; }
      case INT32 	{ return PrimitiveType.INT32; }
      case INT64 	{ return PrimitiveType.INT64; }
      case UINT8 	{ return PrimitiveType.UINT8; }
      case UINT16 { return PrimitiveType.UINT16; }
      case UINT32 { return PrimitiveType.UINT32; }
      case UINT64 { return PrimitiveType.UINT64; }
      case FLOAT 	{ return PrimitiveType.FLOAT; }
      case DOUBLE { return PrimitiveType.DOUBLE; }
      //case NULL 	{ return PrimitiveType.VOID; }
      //case UNSIZED_INT { return PrimitiveType.VOID; }

      case FUNCTION case FUNCTION_STATIC {
        // selfType?
        
  		//returnType:Type,
  		//selfType:Type,
  		//paramTypes:Type[],
    	//invoke:static fn (func:Address[void], obj:Address[void], args:Object[]) -> Object) {

				let isStatic = (typeId == TypeTag.FUNCTION_STATIC);
        let invokeIndex = decoder.readVarInt();
        let returnType = decodeType(decoder);
        let paramTypes = decodeType(decoder);

        //return FunctionType(typeKind:
        return PrimitiveType.VOID;
      }

      case BOUND_METHOD {
        Debug.fail("Implement BOUND_METHOD");
      }

      case TUPLE {
        return DerivedType(Type.TypeKind.TUPLE, decodeTypeList(decoder));
      }

      case UNION {
        return DerivedType(Type.TypeKind.UNION, decodeTypeList(decoder));
      }

      case UNIT {
        Debug.fail("Implement UNIT");
      }

      case ADDRESS {
        Debug.fail("Implement ADDRESS");
      }

      case NARRAY {
        Debug.fail("Implement FUNCTION");
      }

      case TYPEVAR {
        Debug.fail("Implement TYPEVAR");
      }

      case TYPELITERAL {
        Debug.fail("Implement TYPELITERAL");
      }

      case VARIADIC {
        Debug.fail("Implement VARIADIC");
      }
      
		  case COMPOSITE {
        Debug.fail("Implement COMPOSITE");
		  }
		  
		  case DERIVED {
        Debug.fail("Implement DERIVED");
		  }

			case ENUM {
        Debug.fail("Implement ENUM");
			}
			
			else {
			  if typeId >= TypeTag.DERIVED_IMM {
	        Debug.fail("Implement DERIVED_IMM");
			  } else if typeId >= TypeTag.COMPOSITE_IMM {
			    let index = int(typeId) & 0x3f;
			  	let tib = _compositeTypes[index];
			    return getCompositeType(tib);
			  } else if typeId >= TypeTag.ENUM_IMM {
	        Debug.fail("Implement ENUM_IMM");
			  } else {
	        Debug.fail("Invalid type id: ", typeId.toString());
			  }
			}
    }

    return PrimitiveType.VOID;
  }

  private def decodeFieldName(decoder:StreamDecoder) -> String {
    let index = decoder.readVarInt();
    return _names.getName(index);
  }
}
