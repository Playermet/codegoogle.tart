import tart.core.Memory.Address;
import tart.collections.ArrayList;
import tart.collections.ImmutableList;

/** The compressed and encoded reflection data for a type, namespace or module. */
@Reflection(Reflection.Detail.NONE) final class ReflectionMetadata {
  /** Tags used to represent the start of a definition. */
  enum DefnTag : uint8 {
    SCOPE_END = 0,    // End of scope
    MODULE,           // A module definition
    NAMESPACE,        // A namespace definition
    CLASS,            // A class definition
    STRUCT,           // A struct definition
    INTERFACE,        // An interface definitions
    PROTOCOL,         // A protocol definition
    METHOD,           // A method definition
    UNDEF,            // A method un-definition
    OVERRIDE,         // A method override
    CONSTRUCTOR,      // A constructor definition
    MACRO,            // A macro definition
    INDEXER,          // An indexer definition
    PROPERTY,         // A property definition
    VARIABLE,         // A variable definition
    LET,              // An immutable constant
    ENUM,             // An enumeration type
    IMPORT,           // An import definition
    TYPEALIAS,        // A type alias
    PARAM,            // A parameter definition within a method
    TYPE_PARAM,       // A template parameter definition
    ATTRIBUTE,        // An attribute (applies to current scope).
    TEMPLATE_INST,    // A template instantiation

    // Modifier tags which affect the containing scope.

    MOD_ATTRIBUTE = 32,// Modifies a declaration to add an attribute.
    //MOD_STATIC,        // Modifies a declaration to have static storage class
    //MOD_FINAL,         // Modifies a class or method to be final
    //MOD_ABSTRACT,      // Modifies a class or method to be abstract
    MOD_VARIADIC,      // Modifies a parameter to be variadic
    MOD_KEYWORD_ONLY,  // Modifies a parameter to be keyword-only
  }

  @Flags enum DefnFlags : uint8 {
    STATIC,
    ABSTRACT,
    FINAL,
    UNSAFE,
    PROTECTED,
    PRIVATE,
  }

  /** Tags used to define types. */
  enum TypeTag : uint8 {
    VOID = 0,
    BOOL,
    CHAR,
    INT8,
    INT16,
    INT32,
    INT64,
    UINT8,
    UINT16,
    UINT32,
    UINT64,
    FLOAT,
    DOUBLE,
    NULL,
    UNSIZED_INT,

    // Derived types

    FUNCTION = 16,   // Function type (flags, return-type, params...)
    FUNCTION_STATIC, // Function with no 'self' param.
    BOUND_METHOD,    // Bound method (flags, return-type, params...)
    TUPLE,           // Tuple table index follows
    UNION,           // Tuple table index follows
    UNIT,            // ??
    ADDRESS,         // Type table index follows
    NARRAY,          // Type table index and length follows
    TYPEVAR,         // variable name index follows (? should be index ?)
    TYPELITERAL,     // Literal reference to a type
    VARIADIC,        // Type follows

    // Indirect type tags - tag byte is followed by varint table index.

    COMPOSITE = 32,   // Followed by index into composite type table.
    DERIVED = 33,     // Followed by index into derived type table.
    ENUM = 34,        // Followed by index into enum type table.

    // Immediate-mode tags, tag data is in low bits of tag byte.

    ENUM_IMM = 48,       // Low 4 bits are index into enum type table.
    COMPOSITE_IMM = 64,  // Low 6 bits are index into composite type table.
    DERIVED_IMM = 128,   // Low 7 bits are index into derived type table.
  }

  enum SectionTag : uint8 {
    END = 0,
    TYPE_PARAMS = 1,
    BASE_CLASS = 2,
    INTERFACES = 3,
    ATTRIBUTES = 4,
    MEMBER_TYPES = 5,
    NAMESPACES = 6,
    FIELDS = 7,
    METHODS = 8,
    PROPERTIES = 9,
    BASE_TEMPLATE = 10,
    TEMPLATE_PARAMS = 11,
  }

  typealias CallAdapterFn:static fn (func:Address[void], obj:Address[void], args:Object[]) -> Object;
  //typealias GetAdapterFn:static fn (func:Address[void], obj:Address[void]) -> Object;
  //typealias SetAdapterFn:static fn (func:Address[void], obj:Address[void], value:Object);

  typealias MethodPtr:Address[void];

  private {
    var _value:optional Object;
    let _names:NameTable;
    var _strmTypeRefs:Address[ubyte];
    var _strmDefns:Address[ubyte];
    var _nameIndex:int16;
    var _methodBaseIndex:int16;
    var _defnType:DefnTag;
    var _traits:Member.Traits;
    var _derivedTypes:Type[];
    var _compositeTypes:Address[Address[TypeInfoBlock]];
    var _enumTypes:Address[Address[EnumInfoBlock]];
    var _invokeFns:Address[CallAdapterFn];
    var _methods:Address[MethodPtr];
    var _retainedAttrs:Address[Object];
    var _alloc:static fn -> Object;
    // field offsets
    // globals
  }

  undef construct;

  def names:NameTable { get { return _names; } }

  def qualifiedName:String { get { return _names.getQualifiedName(_nameIndex); } }
  def scopeName:String { get { return _names.getScopeName(_nameIndex); } }
  def localName:String { get { return _names.getLocalName(_nameIndex); } }

//  def derivedTypes:Type[] { get { return getDerivedTypes(); } }

  static def getCompositeType(tib:Address[TypeInfoBlock]) -> CompositeType {
    Preconditions.checkArgument(tib is not null);
    var meta = tib.meta;
    Preconditions.checkState(meta is not null);

    if meta._value is not null {
      return typecast[CompositeType](meta._value);
    }

    var type:CompositeType;
    //Debug.writeLnFmt("type: {0} {1} {2}", meta._defnType.toString(), meta._nameIndex.toString(), meta.qualifiedName);
    switch (meta._defnType) {
      case CLASS { type = CompositeType(Type.TypeKind.CLASS, tib); }
      case STRUCT { type = CompositeType(Type.TypeKind.STRUCT, tib); }
      case INTERFACE { type = CompositeType(Type.TypeKind.INTERFACE, tib); }
      case PROTOCOL { type = CompositeType(Type.TypeKind.PROTOCOL, tib); }
      case TEMPLATE_INST {
        Debug.writeLn("Reading base template");
        var baseTemplate = meta.readBaseTemplate();
        //Debug.writeLnFmt("Base template kind is {0}", baseTemplate.typeKind.toString());
        // TODO: Implement template instantiations.
        type = CompositeType(baseTemplate.typeKind, tib, baseTemplate);
      }
      else { throw ArgumentError(
        String.concat("Invalid reflection metadata for type ", meta._defnType.toString())); }
    }

    meta._value = type;
    return type;
  }

  static def getEnumType(eib:Address[EnumInfoBlock]) -> EnumType {
    Preconditions.checkArgument(eib is not null);
    var meta = eib.meta;
    Preconditions.checkState(meta is not null);

    if meta._value is not null {
      return typecast[EnumType](meta._value);
    }

    // TODO: Replace with real base type.
    return EnumType(meta, PrimitiveType.INT32);
  }

/*  def getTypeFromExpr(expr:Address[ubyte]) -> Type {
    let decoder = StreamDecoder(expr);
	  return decodeType(decoder, null);
  } */

  // readModule
  // readType
  // readNamespace

  def readBaseClass(selfType:Type) -> optional CompositeType {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.BASE_CLASS);
    if length != 0 {
      var base = typecast[CompositeType](decodeType(decoder, selfType));
      //Debug.writeLn("Base = ", base.name);
      return base;
    }

    return null;
  }

  def readBaseType -> optional Type {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.BASE_CLASS);
    if length != 0 {
      return decodeType(decoder, null);
    }

    return null;
  }

  def readInterfaces() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.INTERFACES);
    if length != 0 {
      Debug.writeLn("Length of interfaces section = ", length.toString());
    }
  }

  def readBaseTemplate() -> CompositeType {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.BASE_TEMPLATE);
    if length != 0 {
      //Debug.writeLn("Length of base template section = ", length.toString());
      return typecast[CompositeType](decodeType(decoder, null));
    }

    return Memory.zeroPtr();
  }

  def readTypeParams() -> Type[] {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.TYPE_PARAMS);
    let params = ArrayList[Type]();
    if length != 0 {
      let endPos = decoder.position + length;
      while decoder.position < endPos {
        params.add(decodeType(decoder, null));
      }
    }

    return Array.copyOf(params);
  }

  def readTemplateParams() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.TEMPLATE_PARAMS);
    if length != 0 {
      Debug.writeLn("Length of type params section = ", length.toString());
    }
  }

  def readFields() {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.FIELDS);
    if length != 0 {
      Debug.writeLn("Length of field section = ", length.toString());
    }
  }

  def readModuleMethods() -> Method[] {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.METHODS);
    let methods = ArrayList[Method]();
    if length != 0 {
      //Debug.writeLn("Length of method section = ", length.toString());
      let endPos = decoder.position + length;
      while decoder.position < endPos {
        let m = decodeMethod(decoder, null);
        Preconditions.checkState(m.kind == Member.MemberKind.METHOD);
        methods.add(m);
      }
    }

    Debug.writeLnFmt("Returing {0} methods", methods.size);
    return Array.copyOf(methods);
  }

  def readClassMethods(selfType:Type) -> (Method[], Method[]) {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.METHODS);
    let methods = ArrayList[Method]();
    let constructors = ArrayList[Method]();
    if length != 0 {
      //Debug.writeLn("Length of method section = ", length.toString());
      let endPos = decoder.position + length;
      while decoder.position < endPos {
        let m = decodeMethod(decoder, selfType);
        if m.kind == Member.MemberKind.CONSTRUCTOR {
          constructors.add(m);
        } else {
          methods.add(m);
        }
      }
    }

    //Debug.writeLnFmt("Returing {0} constructors {1} methods for {2}", constructors.size, methods.size, qualifiedName);
    return Array.copyOf(constructors), Array.copyOf(methods);
  }
  
  def readMemberTypes() -> Type[] {
    let decoder = StreamDecoder(_strmDefns);
    let length = decoder.seekToSection(SectionTag.MEMBER_TYPES);
    let params = ArrayList[Type]();
    if length != 0 {
      let endPos = decoder.position + length;
      while decoder.position < endPos {
        params.add(decodeType(decoder, null));
      }
    }

    return Array.copyOf(params);
  }

  private def decodeMethod(decoder:StreamDecoder, selfType:optional Type) -> Method {
    let tag = DefnTag(decoder.readByte());
    let flags = DefnFlags(decoder.readByte());
    let name = decodeFieldName(decoder);
    let methodIndex = decoder.readVarInt();
    //Debug.writeLnFmt("Decoding type for method '{0}', method index {1}", name, methodIndex);
    let methodType = typecast[FunctionType](decodeType(decoder, selfType));

    var visibility = Member.Visibility.PUBLIC;
    var traits:Method.Traits = 0;
    var kind:Member.MemberKind = Member.MemberKind.METHOD;

    let attributes = ArrayList[Object]();
    let params = ArrayList[Parameter]();
    let typeParams = ArrayList[Type]();

    if DefnFlags.FINAL in flags {
      traits |= Method.Traits.FINAL;
    }

    if DefnFlags.ABSTRACT in flags {
      traits |= Method.Traits.ABSTRACT;
    }

    if DefnFlags.STATIC in flags {
      traits |= Method.Traits.STATIC;
    }

    if DefnFlags.UNSAFE in flags {
      traits |= Method.Traits.UNSAFE;
    }

    if DefnFlags.PRIVATE in flags {
      visibility = Member.Visibility.PRIVATE;
    } else if (DefnFlags.PROTECTED in flags) {
      visibility = Member.Visibility.PROTECTED;
    }

    switch tag {
      case METHOD {
        // Nothing to do here.
      }

      case UNDEF {
      }

      case OVERRIDE {
        traits |= Method.Traits.OVERRIDE;
      }

      case CONSTRUCTOR {
        kind = Member.MemberKind.CONSTRUCTOR;
      }

      case MACRO {
      }

      else {
        throw DecodingError("Invalid method tag: ", tag.toString());
      }
    }

    var isVariadic = false;
    repeat {
      let tag = DefnTag(decoder.readByte());
      switch tag {
        case SCOPE_END {
          break;
        }

        case ATTRIBUTE {
          let attrIndex = decoder.readVarInt();
          attributes.add(_retainedAttrs[attrIndex]);
        }

        case PARAM {
          let paramName = decodeFieldName(decoder);
          isVariadic = false;
        }

        case MOD_VARIADIC {
          isVariadic = true;
        }

        else {
          throw DecodingError("Invalid parameter tag: ", tag.toString());
        }
      }
    }

    var methodPtr:MethodPtr;
    if methodIndex < _methodBaseIndex {
      let tib = typecast[CompositeType](selfType).typeInfo;
      methodPtr = tib.methodTable[methodIndex];
    } else {
       methodPtr = _methods[methodIndex - _methodBaseIndex];
    }

    //Debug.writeLnFmt("Decoding method named '{0}', type {1}", name, methodType);
    //Debug.writeLnFmt("For method {0} type {1}, method index is {2} of {3}", name, methodType, methodIndex, _methodBaseIndex.toString());

    return Method(name, "", kind, visibility, traits,
    	Array.copyOf(attributes), Array.copyOf(typeParams), methodType, Array.copyOf(params), methodPtr);
  }

  private def decodeType(decoder:StreamDecoder, selfType:optional Type) -> Type {
    let typeId = TypeTag(decoder.readByte());
    return decodeTypeExpr(decoder, typeId, selfType);
  }

  private def decodeDerivedTypeRef(typeIndex:int, selfType:optional Type) -> Type {
    if _derivedTypes is not null {
      if _derivedTypes[typeIndex] is not null {
        return _derivedTypes[typeIndex];
      }
    }

    let decoder = StreamDecoder(_strmTypeRefs);
    let count = decoder.readVarInt();
    if _derivedTypes is null {
      _derivedTypes = Type[](count);
    }

    //Debug.writeLnFmt("Retrieving derived type {0} of {1} in {2}: ", typeIndex, count, qualifiedName);
    Preconditions.checkArgument(typeIndex < count);

    for i = 0; i < typeIndex; ++i {
      skipType(decoder);
    }

    let typeId = TypeTag(decoder.readByte());
    var type:Type;
    switch typeId {
      else {
        _derivedTypes[typeIndex] = decodeTypeExpr(decoder, typeId, selfType);
      }

      case TUPLE
      case UNION {
        let count = decoder.readVarInt();
        let typeParams = Type[](count);
        let typeKind = cond(typeId == TypeTag.TUPLE, Type.TypeKind.TUPLE, Type.TypeKind.UNION);
        //Debug.writeLnFmt("Decoding a referenced {0} with {1} members", typeKind.toString(), count);

        // Assign a value to the derived types array *before* we start decoding types,
        // in case the definition is recursive.
        _derivedTypes[typeIndex] = DerivedType(typeKind, typeParams);
        for i in range(count) {
          let memberType = decodeType(decoder, selfType);
          //Debug.writeLnFmt("{0}. Decoded member type: {1}", i, memberType.toString());
          typeParams[i] = memberType;
        }
      }

      case ADDRESS {
        Debug.fail("Implement ADDRESS");
      }

      case NARRAY {
        Debug.fail("Implement NARRAY");
      }

      case TYPEVAR {
        Debug.fail("Implement TYPEVAR");
      }

      case VARIADIC {
        Debug.fail("Implement VARIADIC");
      }

      case DERIVED {
        Debug.fail("Implement DERIVED");
      }
    }

    return _derivedTypes[typeIndex];
  }

  /** Decode an inline type expression. */
  private def decodeTypeExpr(decoder:StreamDecoder, typeId:TypeTag, selfType:optional Type) -> Type {
    switch typeId {
      case VOID   { return PrimitiveType.VOID; }
      case BOOL   { return PrimitiveType.BOOL; }
      case CHAR   { return PrimitiveType.CHAR; }
      case INT8   { return PrimitiveType.INT8; }
      case INT16  { return PrimitiveType.INT16; }
      case INT32  { return PrimitiveType.INT32; }
      case INT64  { return PrimitiveType.INT64; }
      case UINT8  { return PrimitiveType.UINT8; }
      case UINT16 { return PrimitiveType.UINT16; }
      case UINT32 { return PrimitiveType.UINT32; }
      case UINT64 { return PrimitiveType.UINT64; }
      case FLOAT  { return PrimitiveType.FLOAT; }
      case DOUBLE { return PrimitiveType.DOUBLE; }
      //case NULL   { return PrimitiveType.VOID; }
      //case UNSIZED_INT { return PrimitiveType.VOID; }

      case FUNCTION case FUNCTION_STATIC {
        let isStatic = (typeId == TypeTag.FUNCTION_STATIC);
        let invokeIndex = decoder.readVarInt();
        let returnType = decodeType(decoder, selfType);
        let paramTypes = typecast[DerivedType](decodeType(decoder, selfType)).typeParams;
        let fnType = FunctionType(
            returnType,
            cond(isStatic, null, selfType),
            paramTypes,
            _invokeFns[invokeIndex]);
        //Debug.writeLnFmt("Function type {0} : invoke {1}", fnType, invokeIndex);
        return fnType;
      }

      case BOUND_METHOD {
        Debug.fail("Implement BOUND_METHOD");
      }

      case TUPLE
      case UNION {
        let count = decoder.readVarInt();
        let typeParams = Type[](count);
         let typeKind = cond(typeId == TypeTag.TUPLE, Type.TypeKind.TUPLE, Type.TypeKind.UNION);
        //Debug.writeLnFmt("Decoding an inline {0} with {1} members", typeKind.toString(), count);
        for i in range(count) {
          let memberType = decodeType(decoder, selfType);
          //Debug.writeLnFmt("{0}. Decoded member type: {1}", i, memberType.toString());
          typeParams[i] = memberType;
        }
        return DerivedType(typeKind, typeParams);
      }

      case UNIT {
        Debug.fail("Implement UNIT");
      }

      case ADDRESS {
        Debug.fail("Implement ADDRESS");
      }

      case NARRAY {
        Debug.fail("Implement FUNCTION");
      }

      case TYPEVAR {
        Debug.fail("Implement TYPEVAR");
      }

      case TYPELITERAL {
        Debug.fail("Implement TYPELITERAL");
      }

      case VARIADIC {
        Debug.fail("Implement VARIADIC");
      }

      case COMPOSITE {
        let index = decoder.readVarInt();
        let tib = _compositeTypes[index];
        return getCompositeType(tib);
      }

      case DERIVED {
        let index = decoder.readVarInt();
        return decodeDerivedTypeRef(index, selfType);
      }

      case ENUM {
        let index = decoder.readVarInt();
        return getEnumType(_enumTypes[index]);
      }

      else {
        if typeId >= TypeTag.DERIVED_IMM {
          let index = int(typeId) & 0x7f;
          return decodeDerivedTypeRef(index, selfType);
        } else if typeId >= TypeTag.COMPOSITE_IMM {
          let index = int(typeId) & 0x3f;
          //Debug.writeLnFmt("Composite type index: {0} of RMD for {1}", index, qualifiedName);
          let tib = _compositeTypes[index];
          return getCompositeType(tib);
        } else if typeId >= TypeTag.ENUM_IMM {
          let index = int(typeId) & 0x0f;
          let eib = _enumTypes[index];
          return getEnumType(eib);
        } else {
          Debug.fail("Invalid type id: ", typeId.toString());
        }
      }
    }

    return PrimitiveType.VOID;
  }

  private def skipType(decoder:StreamDecoder) {
    let typeId = TypeTag(decoder.readByte());
    //Debug.writeLnFmt("  Skipping type {0}", typeId.toString());
    switch typeId {
      case VOID
      case BOOL
      case CHAR
      case INT8
      case INT16
      case INT32
      case INT64
      case UINT8
      case UINT16
      case UINT32
      case UINT64
      case FLOAT
      case DOUBLE {
      }
      //case NULL
      //case UNSIZED_INT

      case FUNCTION case FUNCTION_STATIC {
        decoder.readVarInt();
        skipType(decoder); // Return type
        skipType(decoder); // Param types
      }

      case BOUND_METHOD {
        Debug.fail("Implement BOUND_METHOD");
      }

      case TUPLE
      case UNION {
        let count = decoder.readVarInt();
        for i in range(count) {
          skipType(decoder);
        }
      }

      case UNIT {
        Debug.fail("Implement UNIT");
      }

      case ADDRESS {
        Debug.fail("Implement ADDRESS");
      }

      case NARRAY {
        Debug.fail("Implement FUNCTION");
      }

      case TYPEVAR {
        Debug.fail("Implement TYPEVAR");
      }

      case TYPELITERAL {
        Debug.fail("Implement TYPELITERAL");
      }

      case VARIADIC {
        Debug.fail("Implement VARIADIC");
      }

      case COMPOSITE {
        Debug.fail("Implement COMPOSITE");
      }

      case DERIVED {
        Debug.fail("Implement DERIVED");
      }

      case ENUM {
        Debug.fail("Implement ENUM");
      }

      else {
        if typeId >= TypeTag.DERIVED_IMM {
        } else if typeId >= TypeTag.COMPOSITE_IMM {
        } else if typeId >= TypeTag.ENUM_IMM {
        } else {
          Debug.fail("Invalid type id: ", typeId.toString());
        }
      }
    }
  }

  private def decodeFieldName(decoder:StreamDecoder) -> String {
    let index = decoder.readVarInt();
    return _names.getName(index);
  }
}
