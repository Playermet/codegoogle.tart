import tart.annex.Intrinsic;
import tart.annex.Essential;
import tart.collections.ImmutableList;
import tart.core.Memory.Address;

/** Description of a compiled module. */
@Reflection(Reflection.Detail.NONE) final class Module {
  private {
    let _meta:ReflectionMetadata;
    //var _encodedTypeExports:Address[ubyte];
    var _nameIndex:int16;
    var _memberTypes:Type[];
    var _methods:Method[];
    //var _typesNew: optional Type[];
    //var _globalsNew: optional Field[];

    undef construct();
    
//    def decodeTypeExports {
	    //let stream = ReflectionDataStream(_encodedTypeExports);
//	    let count = stream.
//    }
  }

  /** Short name of the module. */
  final def name:String { get {
    return _meta.names.getLocalName(_nameIndex);
  } }

  /** Fully-qualified name of the module. */
  final def qualifiedName:String { get {
    return _meta.names.getQualifiedName(_nameIndex);
  } }

  /** Name of the package containing the module. */
  final def packageName:String { get {
    return _meta.names.getScopeName(_nameIndex);
  } }

  /** Array of types defined in this module. */
  final def types:Type[] { get { decodeTypes(); return self._memberTypes; } }

  /** Array of types defined in this module. */
  final def methods:Method[] { get { decodeMethods(); return self._methods; } }

  /** Returns a reference to the caller's module. */  
  @Intrinsic static def thisModule() -> Module;

  /** Returns a reference to module that contains the specified type. */
  @Intrinsic static def of[%T](type:TypeLiteral[T]) -> Module;

  private final def decodeMethods {
    if self._methods is null {
	    self._methods = _meta.readModuleMethods();
    }
  }

  private final def decodeTypes {
    if self._memberTypes is null {
      let memberTypes = _meta.readMemberTypes();
	    //Debug.writeLnFmt("Assigning member types for {0}", self.name);
	    self._memberTypes = memberTypes;
	    //Debug.writeLn("Assigned member types");
    }
  }

  def findMethod(name:String) -> Method or void {
    for m in _methods {
      if m.name == name {
        return m;
      }
    }

    return;
  }
}
