import tart.annex.Intrinsic;
import tart.annex.Essential;
import tart.collections.ImmutableList;
import tart.core.Memory.Address;

/** Description of a compiled module. */
@Reflection(Reflection.Detail.NONE) final class Module {
  private {
    let _meta:ReflectionMetadata;
    //var _encodedTypeExports:Address[ubyte];
    //var _encodedMethodExports:Address[ubyte];
    var _nameIndex:int16;
    var _types:Type[];
    var _methods:Method[];
    //var _typesNew: optional Type[];
    //var _methodsNew: optional Method[];
    //var _globalsNew: optional Field[];

    undef construct();
    
//    def decodeTypeExports {
	    //let stream = ReflectionDataStream(_encodedTypeExports);
//	    let count = stream.
//    }
  }

  /** Short name of the module. */
  final def name:String { get {
    return _meta.names.getLocalName(_nameIndex);
  } }

  /** Fully-qualified name of the module. */
  final def qualifiedName:String { get {
    return _meta.names.getQualifiedName(_nameIndex);
  } }

  /** Name of the package containing the module. */
  final def packageName:String { get {
    return _meta.names.getScopeName(_nameIndex);
  } }

  /** Array of types defined in this module. */
  final def types:Type[] { get { return self._types; } }

  /** Array of types defined in this module. */
  //final def typesNew:ImmutableList[Type] { get { return self._types; } }

  /** Array of types defined in this module. */
  final def methods:Method[] { get { return self._methods; } }

	/** The strings table for this module. */ 
  //final def strings:ImmutableList[String] { get { return self._constants.strings; } }

  /** Returns a reference to the caller's module. */  
  @Intrinsic static def thisModule() -> Module;

  /** Returns a reference to module that contains the specified type. */
  @Intrinsic static def of[%T](type:TypeLiteral[T]) -> Module;

  def findMethod(name:String) -> Method or void {
    for m in _methods {
      if m.name == name {
        return m;
      }
    }

    return;
  }
}
