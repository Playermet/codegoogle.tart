import tart.annex.Coalesce;
import tart.collections.Collection;
import tart.collections.Copyable;
import tart.core.Memory.addressOf;
import tart.core.Memory.ptrDiff;
import tart.core.Memory.Address;
import tart.core.Math.min;
import tart.gc.TraceMethod;
import tart.gc.TraceAction;

/** Built-in array class */
@Coalesce public final class Array[%ElementType] : Collection[ElementType], Copyable[ElementType] {
  private {
    var _size:int;
    var _data:FlexibleArray[ElementType];

    /** Array allocator function */
    static def alloc(size:int) -> Array {
      let self:Array =  __flexAlloc(size);
      self._size = size;
      return self;
    }

		/** Custom trace method for garbage collection to handle variable-length object. */
    @TraceMethod def __trace(action:TraceAction) {
      for i = 0; i < _size; ++i {
        action.trace(_data[i]);
      }
    }
  }

  /** Construct an array of a given length */
  static def create(size:int) -> Array {
    Preconditions.checkArgument(size >= 0);
    if (size == 0) {
      return []; // Compiler optimizes empty arrays as static singletons
    }

    let self:Array = alloc(size);
    // TODO: Need to initialize the array elements to default values.
    // Memory.initToDefaultValues(addressOf(data[0]), end);
    return self;
  }

  /** Static factory function which takes advantage of the built-in behavior of
      variadic parameters to build an 'Array'. */
  static def of(elements:ElementType...) -> Array {
    return elements;
  }

  /** Static factory function which builds a new 'Array' from a 'Collection'. */
  static def copyOf(collection:Collection[ElementType]) -> Array {
    let size = collection.size;
    if size == 0 {
      return []; // Compiler optimizes empty arrays as static singletons
    }

    let result:Array = alloc(size);
    match collection as copyable:Copyable[ElementType] {
      copyable.copyElements(addressOf(result._data[0]), 0, size);
    } else {
      var index = 0;
      for el in collection {
        result._data[index++] = el;
      }
    }

		return result;
  }

  /** True if the array is zero size. */
  def isEmpty:bool {
    get { return self._size == 0; }
  }

  /** The length of the array. */
  def size:int {
    get { return _size; }
  }

  @Unsafe def data:Address[ElementType] { get { return addressOf(_data[0]); } }

  /** Array element access. */
  def [index:int]:ElementType {
    get {
      Preconditions.checkIndex(index >= 0 and index < _size);
      return self._data[index];
    }
    set {
      Preconditions.checkArgument(index >= 0 and index < _size);
      self._data[index] = value;
    }
  }

  /** Return an immutable buffer representation of this array's data. */
  def asBuffer() -> Memory.Buffer[ElementType] {
    return Memory.Buffer[ElementType](self, addressOf(self._data[0]), _size);
  }

  /** Copy the elements of this collection to a destination address. */
  def copyElements(dstAddr:Address[ElementType], srcOffset:int, count:int) {
    Preconditions.checkIndex(count >= 0);
    Preconditions.checkIndex(srcOffset >= 0 and srcOffset <= _size);
    count = min(count, _size - srcOffset);
    if count > 0 {
      Memory.arrayCopy(dstAddr, addressOf(_data[srcOffset]), count);
    }
  }

  /** Move elements around in the array. */
  def moveElements(dstOffset:int, srcOffset:int, count:int) {
    Preconditions.checkIndex(count >= 0);
    Preconditions.checkIndex(srcOffset >= 0 and srcOffset + count <= _size);
    Preconditions.checkIndex(dstOffset >= 0 and dstOffset + count <= _size);
    if count > 0 {
      Memory.arrayMove(addressOf(_data[dstOffset]), addressOf(_data[srcOffset]), count);
    }
  }

  /** Copy elements from the specified copyable into this array.
      Parameters:
        dstOffset - The destination index in this array.
        src - The source collection to copy from.
        srcOffset - The offset in the source collection to start copying from.
        count - the number of elements to copy.
  */
  def copyFrom(dstOffset:int, src:Copyable[ElementType], srcOffset:int, count:int) {
    let srcSize = src.size;
    Preconditions.checkIndex(count >= 0);
    Preconditions.checkIndex(dstOffset >= 0 and dstOffset <= _size);
    Preconditions.checkIndex(srcOffset >= 0 and srcOffset <= srcSize);
    Preconditions.checkIndex(srcOffset + count <= srcSize);
    Preconditions.checkIndex(dstOffset + count <= _size);
    src.copyElements(addressOf(_data[dstOffset]), srcOffset, count);
  }

  /** Iterate over the elements of the array. */
  def iterate -> Iterator[ElementType] {
    return ArrayIterator(self);
  }

  /** Copy 'count' elements, starting from offset 'srcOffset' in array 'src', to offset
      'dstOffset' in array 'dst'.
   */
  static def copyElements(dst:Array, dstOffset:int, src:Array, srcOffset:int, count:int) {
    Preconditions.checkIndex(count >= 0);
    Preconditions.checkIndex(dstOffset >= 0 and dstOffset <= dst._size);
    Preconditions.checkIndex(srcOffset >= 0 and srcOffset <= src._size);
    count = min(count, dst._size - dstOffset, src._size - srcOffset);
    if count > 0 {
      Memory.arrayMove(addressOf(dst._data[dstOffset]), addressOf(src._data[srcOffset]), count);
    }
  }

  @Coalesce private final class ArrayIterator : Iterator[ElementType], HasLength {
    private var array:Array;
    private var index:int;

    def construct(array:Array) {
      self.array = array;
      self.index = 0;
    }

    def next() -> ElementType or void {
      if (self.index < self.array._size) {
        return self.array._data[self.index++];
      } else {
        return;
      }
    }

    def length:int { get { return array._size; } }
    def size:int { get { return array._size; } }
  }
}
