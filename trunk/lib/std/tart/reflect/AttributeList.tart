import tart.collections.List;
import tart.core.Memory.Address;
import tart.gc.TraceMethod;
import tart.gc.TraceAction;

/** An immutable list of attributes that points to a statically-initialized array. */
final class AttributeList : List[Attribute] {
  private {
    var _size:int;
    var _data:FlexibleArray[Attribute];

    /** Custom trace method for garbage collection to handle variable-length object. */
    @TraceMethod def __trace(action:TraceAction) {
      for i = 0; i < _size; ++i {
        action.trace(_data[i]);
      }
    }
  }

  // TODO: Make this undef. (Undefs should automatically throw UnsupportedOperationError().) */
  def add(e:Attribute) {
    throw UnsupportedOperationError();
  }

  def insert(position:int, e:Attribute) {
    throw UnsupportedOperationError();
  }

  def remove(index:int) {
    throw UnsupportedOperationError();
  }

  def [index:int]:Attribute {
    get {
      return _data[index];
    }

    set {
      throw UnsupportedOperationError();
    }
  }

  def clear {
    throw UnsupportedOperationError();
  }

  def size:int {
    get { return self._size; }
  }

  def isEmpty:bool {
    get { return self._size == 0; }
  }

  def contains(type:Attribute) -> bool {
    for i = 0; i < _size; ++i {
      return true if self._data[i] == type;
    }
    return false;
  }

  def iterate -> Iterator[Attribute] {
    return IteratorImpl(self);
  }

  private final class IteratorImpl : Iterator[Attribute], HasLength {
    private var _typeList:AttributeList;
    private var _index:int;

    def construct(typeList:AttributeList) {
      self._typeList = typeList;
      self._index = 0;
    }

    def next() -> Attribute or void {
      if (self._index < self._typeList._size) {
        return self._typeList._data[self._index++];
      } else {
        return;
      }
    }

    def length:int { get { return _typeList._size; } }
  }
}
