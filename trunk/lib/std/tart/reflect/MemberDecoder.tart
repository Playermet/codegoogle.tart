import tart.collections.ArrayList;
import tart.collections.ImmutableList;
import tart.core.Memory.Address;

/** StreamDecoder subclass that knows how to decode serialized definitions.
 */
final class MemberDecoder : StreamDecoder {
  enum SectionTag : uint8 {
    END = 0,
    TYPE_PARAMS = 1,
    ATTRIBUTES = 2,
    NAMESPACES = 3,
    FIELDS = 4,
    METHODS = 5,
    PROPERTIES = 6,
    BASE_TEMPLATE = 7,
    TEMPLATE_PARAMS = 8,
  }

  enum MemberTag : uint8 {
    SCOPE_END = 0,    // End of scope
    NAMESPACE,        // A namespace definition
    METHOD,           // A method definition
    UNDEF,            // A method un-definition
    OVERRIDE,         // A method override
    CONSTRUCTOR,      // A constructor definition
    MACRO,            // A macro definition
    INDEXER,          // An indexer definition
    PROPERTY,         // A property definition
    VARIABLE,         // A variable definition
    LET,              // An immutable constant
    IMPORT,           // An import definition
    PARAM,            // A parameter definition within a method
    TYPE_PARAM,       // A template parameter definition
    ATTRIBUTE,        // An attribute (applies to current scope).
    TEMPLATE_INST,    // A template instantiation

    // Modifier tags which affect the containing scope.

    MOD_ATTRIBUTE = 32,// Modifies a declaration to add an attribute.
    //MOD_STATIC,        // Modifies a declaration to have static storage class
    //MOD_FINAL,         // Modifies a class or method to be final
    //MOD_ABSTRACT,      // Modifies a class or method to be abstract
    MOD_VARIADIC,      // Modifies a parameter to be variadic
    MOD_KEYWORD_ONLY,  // Modifies a parameter to be keyword-only
  }

  @Flags enum DefnFlags : uint8 {
    STATIC,
    ABSTRACT,
    FINAL,
    UNSAFE,
    PROTECTED,
    PRIVATE,
  }

  typealias MethodPtr:Address[void];

	private {
  	var _names:NameTable;
  	var _types:Address[Type];
  	var _globals:Address[Object];
  	var _methods:Address[MethodPtr];
  	var _classMethods:Address[MethodPtr];
  	var _methodBaseIndex:int;
	}

  def construct(
  		data:Address[ubyte],
  		names:NameTable,
  		types:Address[Type],
  		globals:Address[Object],
  		methods:Address[MethodPtr],
  		classMethods:Address[MethodPtr],
  		methodBaseIndex:int) {
    super(data);
    self._names = names;
    self._types = types;
    self._globals = globals;
    self._methods = methods;
    self._classMethods = classMethods;
    self._methodBaseIndex = methodBaseIndex;
  }
  
  def seekToSection(sectionTag:SectionTag) -> int {
    repeat {
      var tag = readByte();
      return 0 if tag is SectionTag.END;
      var length = readVarInt();
      return length if tag is ubyte(sectionTag);
      _pos += length;
    }
  }

  def decodeMethod -> Method {
    let tag = MemberTag(readByte());
    let flags = DefnFlags(readByte());
    let name = decodeFieldName();
    let typeIndex = readVarInt();
    let methodIndex = readVarInt();
    //Debug.writeLnFmt("Decoding type for method '{0}', method index {1}, type Index {2}",
    //		name, methodIndex, typeIndex);
    let methodType = typecast[FunctionType](_types[typeIndex]);
    //Debug.writeLnFmt("Type is {0}", methodType);

    var visibility = Member.Visibility.PUBLIC;
    var traits:Method.Traits = 0;
    var kind:Member.MemberKind = Member.MemberKind.METHOD;

    let attributes = ArrayList[Object]();
    let params = ArrayList[Parameter]();
    let typeParams = ArrayList[Type]();

    if DefnFlags.FINAL in flags {
      traits |= Method.Traits.FINAL;
    }

    if DefnFlags.ABSTRACT in flags {
      traits |= Method.Traits.ABSTRACT;
    }

    if DefnFlags.STATIC in flags {
      traits |= Method.Traits.STATIC;
    }

    if DefnFlags.UNSAFE in flags {
      traits |= Method.Traits.UNSAFE;
    }

    if DefnFlags.PRIVATE in flags {
      visibility = Member.Visibility.PRIVATE;
    } else if (DefnFlags.PROTECTED in flags) {
      visibility = Member.Visibility.PROTECTED;
    }

    switch tag {
      case METHOD {
        // Nothing to do here.
      }

      case UNDEF {
      }

      case OVERRIDE {
        traits |= Method.Traits.OVERRIDE;
      }

      case CONSTRUCTOR {
        kind = Member.MemberKind.CONSTRUCTOR;
      }

      case MACRO {
      }

      else {
        throw DecodingError("Invalid method tag: ", tag.toString());
      }
    }

    var isVariadic = false;
    repeat {
      let tag = MemberTag(readByte());
      switch tag {
        case SCOPE_END {
          break;
        }

        case ATTRIBUTE {
          let attrIndex = readVarInt();
          attributes.add(_globals[attrIndex]);
        }

        case PARAM {
          let paramName = decodeFieldName();
          isVariadic = false;
        }

        case MOD_VARIADIC {
          isVariadic = true;
        }

        else {
          throw DecodingError("Invalid parameter tag: ", tag.toString());
        }
      }
    }

    var methodPtr:MethodPtr;
    if methodIndex < _methodBaseIndex {
      // Take the methods from the class dispatch table.
      methodPtr = _classMethods[methodIndex];
    } else {
      // Take the methods from the reflected method table.
      methodPtr = _methods[methodIndex - _methodBaseIndex];
    }

    //Debug.writeLnFmt("Decoding method named '{0}', type {1}", name, methodType);
    //Debug.writeLnFmt("For method {0} type {1}, method index is {2} of {3}", name, methodType, methodIndex, _methodBaseIndex.toString());

    return Method(name, kind, visibility, traits,
    		ImmutableList.copyOf(attributes),
    		ImmutableList.copyOf(typeParams),
    		methodType,
    		ImmutableList.copyOf(params),
    		methodPtr);
  }

  private def decodeFieldName() -> String {
    let index = readVarInt();
    return _names.getName(index);
  }
}
