import tart.collections.Collection;
import tart.collections.List;
import tart.core.Memory.Address;
import tart.gc.TraceMethod;
import tart.gc.TraceAction;

/** An immutable list of attributes that points to a statically-initialized array.
    InheritDoc: members
 */
final class PropertyList : List[Property] {
  private {
    var _size:int;
    var _data:FlexibleArray[Property];

    /** Custom trace method for garbage collection to handle variable-length object. */
    @TraceMethod def __trace(action:TraceAction) {
      for i = 0; i < _size; ++i {
        action.trace(_data[i]);
      }
    }
  }

  undef add(e:Property);
  undef addAll(e:Collection[Property]);
  undef insert(position:int, e:Property);
  undef insertAll(position:int, e:Collection[Property]);
  undef remove(index:int);
  undef clear;

  def [index:int]:Property {
    get {
      return _data[index];
    }

    set {
      throw UnsupportedOperationError();
    }
  }

  def size:int {
    get { return self._size; }
  }

  def isEmpty:bool {
    get { return self._size == 0; }
  }

  def contains(type:Property) -> bool {
    for i = 0; i < _size; ++i {
      if self._data[i] == type {
        return true;
      }
    }
    return false;
  }

  def iterate -> Iterator[Property] {
    return IteratorImpl(self);
  }

  private final class IteratorImpl : Iterator[Property], HasLength {
    private var _typeList:PropertyList;
    private var _index:int;

    def construct(typeList:PropertyList) {
      self._typeList = typeList;
      self._index = 0;
    }

    def next() -> Property or void {
      if (self._index < self._typeList._size) {
        return self._typeList._data[self._index++];
      } else {
        return;
      }
    }

    def length:int { get { return _typeList._size; } }
  }
}
