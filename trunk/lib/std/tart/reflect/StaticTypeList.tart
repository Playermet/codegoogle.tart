import tart.collections.List;
import tart.core.Memory.Address;
import tart.gc.TraceMethod;
import tart.gc.TraceAction;

/** An immutable list of types that points to a statically-initialized array. */
final class StaticTypeList : List[Type] {
  private {
    var _size:int;
    var _data:FlexibleArray[Type];

		/** Custom trace method for garbage collection to handle variable-length object. */
    @TraceMethod def __trace(action:TraceAction) {
      for i = 0; i < _size; ++i {
        action.trace(_data[i]);
      }
    }
  }

  undef construct;

	// TODO: Make this undef. (Undefs should automatically throw UnsupportedOperationError().) */
  def add(e:Type) {
    throw UnsupportedOperationError();
  }

  def insert(position:int, e:Type) {
    throw UnsupportedOperationError();
  }

  def remove(index:int) {
    throw UnsupportedOperationError();
  }

  def [index:int]:Type {
    get {
      return _data[index];
    }

    set {
      throw UnsupportedOperationError();
    }
  }

  def clear {
    throw UnsupportedOperationError();
  }

  def size:int {
    get { return self._size; }
  }

  def isEmpty:bool {
    get { return self._size == 0; }
  }

  def contains(type:Type) -> bool {
    for i = 0; i < _size; ++i {
			return true if self._data[i] == type;
    }
    return false;
  }

  def iterate -> Iterator[Type] {
    return StaticTypeListIterator(self);
  }

  private final class StaticTypeListIterator : Iterator[Type], HasLength {
    private var _typeList:StaticTypeList;
    private var _index:int;

    def construct(typeList:StaticTypeList) {
      self._typeList = typeList;
      self._index = 0;
    }

    def next() -> Type or void {
      if (self._index < self._typeList._size) {
        return self._typeList._data[self._index++];
      } else {
        return;
      }
    }

    def length:int { get { return _typeList._size; } }
  }
}
