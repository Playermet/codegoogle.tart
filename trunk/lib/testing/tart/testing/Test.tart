import tart.reflect.Method;
import tart.reflect.Module;
import tart.reflect.Package;
import tart.reflect.ComplexType;
import tart.reflect.Type;

class Test {
  import namespace Asserts;
  
  /** Run all of the test cases in the specified package. */
  static def runAllTests(package:Package) -> int32 {
    var overallStatus = 0;
    for mod in package.modules {
      let testStatus = runAllTests(mod);
      if testStatus != 0 {
        overallStatus = testStatus;
      }
    }

    return overallStatus;
  }

  /** Run all of the test cases in the specified module. */
  static def runAllTests(mod:Module) -> int32 {
    Debug.writeLn("Module: ", mod.name, " symbols: ", mod.types.length.toString());
    for type in mod.types {
      //classify type as complex:ComplexType {
	      //Debug.writeLn(complex.name);
      //}
    }
    
    return 0;
  }
  
  static def run[%T](testType:TypeLiteral[T]) -> int32 {
    var testClass:ComplexType = ComplexType.of(T);
    var testInstance = typecast[Test](testClass.create());
    return testInstance.runTests(testClass);
  }

  /** Test fixture setup method. Will be called before every test. */
  def setUp() {}

  /** Test fixture teardown method. Will be called after every test. */
  def tearDown() {}
  
  final def runTests[%T](testType:TypeLiteral[T]) -> int32 {
    return runTests(ComplexType.of(T));
  }

  final def runTests(testClass:ComplexType) -> int32 {
    for method in testClass.methods {
      if method.name.startsWith("test") {
        Debug.writeLn("[Running] ", self.__typeName, ".", method.name);
	      if not runTestMethod(method) {
	        Debug.writeLn("[FAIL   ]");
	        return 1;
	      }
      }
    }

    Debug.writeLn("[OK     ]");
    return 0;
  }

  def runTestMethod(test:Method) -> bool {
    try {
      setUp();
      test.call(self);
      tearDown();
      return true;
      // TODO: Save test results
    } catch (t:Throwable) {
      Debug.fail(self.__typeName, ".", test.name, " failed: ", t.toString());
      return false;
    }
  }
}
