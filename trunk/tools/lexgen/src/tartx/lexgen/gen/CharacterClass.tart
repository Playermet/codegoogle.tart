import tart.collections.List;
import tart.collections.ArrayList;

/** An ordered set of character ranges, used to define a character class pattern
    such as [a-zA-Z]. */
class CharacterClass : Iterable[CharacterClass.Range] {
  struct Range {
    let begin:char;
    let end:char;
    
    def construct(begin:char, end:char) {
      self.begin = begin;
      self.end = end;
    }
    
    def contains(c:char) -> bool {
      return c >= begin and c < end;
    }

    def contains(r:Range) -> bool {
      return r.begin >= begin and r.end <= end;
    }

    def contains(first:char, last:char) -> bool {
      return first >= begin and last <= end;
    }
    
    def computeHash() -> uint64 {
      return Hashing.hash(begin) + Hashing.hash(end);
    }
    
    def format(sb:StringBuilder) {
      if int(end) == int(begin) + 1 {
        formatChar(sb, begin);
      } else {
        formatChar(sb, begin);
        sb.append('-');
        formatChar(sb, end - 1);
      }
    }
  }
  
  private {
    var ranges = ArrayList[Range]();
  }

  /** No-arg constructor. */
  def construct() {}

  /** Copy constructor. */    
  def construct(toCopy:CharacterClass) {
    add(toCopy);
  }
  
  /** Single character range constructor */
  def construct(a:char) {
    add(a);
  }

  /** Character range constructor. */
  def construct(low:char, high:char) {
    add(low, high);
  }
  
  /** Multiple character range constructor. */
  def construct(ranges:Range...) {
    for rg in ranges {
    	add(rg);
    }
  }
  
  /** Return the number of ranges in this character class. */
  def count:int { get { return ranges.size; } }

  /** Return true if this character class contains no characters. */
  def empty:bool { get { return ranges.size == 0; } }
  
  /** Iterate through the list of ranges. */
  def iterate -> Iterator[Range] {
    return ranges.iterate();
  }

  /** Returns true if this appears to be an inverted (^) character range. */  
  def inverted(vocabulary:Range) -> bool {
    return ranges.size > 1
        and ranges[0].begin == vocabulary.begin
        and ranges[ranges.size - 1].end == vocabulary.end;
  }
  
  /** Add a single character to this character class. */
  def add(c:char) {
    add(Range(c, c + 1));
  }
  
  /** Add a range of characters to this class. */
  def add(low:char, high:char) {
    add(Range(low, high));
  }
  
  /** Add a range of characters to this class, including the high character. */
  def addInclusive(low:char, high:char) {
    add(Range(low, high + 1));
  }
  
  /** Add a range of characters to this class. */
  def add(toAdd:Range) {
    var index:int = 0;
    while index < ranges.size {
      let rg:Range = ranges[index];
      if toAdd.begin > rg.end {
        index++;
      } else if toAdd.end < rg.begin {
        break;
      } else if toAdd.end < rg.end {
        ranges[index] = Range(toAdd.begin, rg.end);
        return;
      } else {
        var end = toAdd.end;
        while index + 1 < ranges.size {
          let rnext = ranges[index + 1];
          if rnext.begin <= end {
            if rnext.end > end {
              end = rnext.end;
            }
            
            ranges.remove(index + 1);
          } else {
            break;
          }
        }
        
        ranges[index] = Range(rg.begin, end);
        return;
      }
    }

    ranges.insert(index, toAdd);
  }
  
  /** Add (i.e. union) all characters in the character class 'cl' to this class. */
  def add(cl:CharacterClass) {
    var index:int = 0;
    for toAdd:Range in cl.ranges {
      repeat {
        if index >= ranges.size {
          ranges.add(toAdd);
          index++;
          break;
        }

        var rg:Range = ranges[index];
        if toAdd.begin > rg.end {
          index++;
        } else if toAdd.end < rg.begin {
          ranges.insert(index, toAdd);
          index++;
          break;
        } else if toAdd.end < rg.end {
          ranges[index] = Range(Math.min(toAdd.begin, rg.begin), rg.end);
          break;
        } else {
          rg = Range(Math.min(toAdd.begin, rg.begin), toAdd.end);
          while index + 1 < ranges.size {
            let rnext:Range = ranges[index + 1];
            if rnext.begin <= rg.end {
              if rnext.end > rg.end {
                rg = Range(rg.begin, rnext.end);
              }
              ranges.remove(index + 1);
            } else {
              break;
            }
          }
          ranges[index] = rg;
          break;
        }
      }
    }
  }

	/** Remove all characters in the character class 'cl' from this class. */ 
  def remove(cl:CharacterClass) {
    var index:int = 0;
    for toRemove in cl.ranges {
      while index < ranges.size {
        let rg = ranges[index];
        if rg.end <= toRemove.begin {
          index++;
        } else if rg.begin >= toRemove.end {
          break;
        } else if rg.begin < toRemove.begin {
          // Add a new range because we created a hole
          if rg.end > toRemove.end {
            ranges.insert(index + 1, Range(toRemove.end, rg.end));
          }
                  
          ranges[index] = Range(rg.begin, toRemove.begin);
          index++;
        } else if rg.end > toRemove.end {
          ranges[index] = Range(toRemove.end, rg.end);
        } else {
          ranges.remove(index);
        }
      }
    }
  }
  
  def invert(vocab:Range) {
  }
  
  def contains(ch:char) -> bool {
    return contains(Range(ch, ch + 1));
  }
  
  def contains(low:char, high:char) -> bool {
    return contains(Range(low, high));
  }
  
  def contains(range:Range) -> bool {
    for r in ranges {
      break if r.begin >= range.end;
      return true if range in r;
    }
    
    return false;
  }
  
  override toString -> String {
    let sb = StringBuilder();
    for r in ranges {
      r.format(sb);
    }
    
    return sb.toString();
  }

  static def formatChar(sb:StringBuilder, ch:char) {
    switch ch {
      case '\n' { sb.append("\\n"); }
      case '\r' { sb.append("\\r"); }
      case '\t' { sb.append("\\t"); }
      case '\b' { sb.append("\\b"); }
      case ']'  { sb.append("\\]"); }
      case '\\' { sb.append("\\\\"); }
      case '\'' { sb.append("\\\'"); }
      case '\"' { sb.append("\\\""); }
      case '\-' { sb.append("\\-"); }
      else {
		    if ch >= 32 and ch <= 127 {
		      sb.append(ch);
    	  } else if ch < 256 {
    	    // TODO: Implement
		    } else {
    	    // TODO: Implement
		    }
      }
    }
  }
}
