import Memory.Address;
import Memory.deref;
import Memory.reinterpretPtr;
import Memory.objectReference;
import tart.testing.Test;
import tart.gc.TraceAction;
import tart.gc.GCRuntimeSupport;

@EntryPoint
def main(args:String[]) -> int32 {
  return Test.run(TraceTest);
}

/** TraceAction that counts the number of non-null pointers. */
class TraceCounter : TraceAction {
  private var _count:int = 0;
  def tracePointer(ptrAddr:Address[Object]) {
    var obj:Object = ptrAddr[0];
    if obj is not null {
      ++_count;
	    if obj.type is not null {
	      var s = obj.__typeName;
  	    Debug.assertTrue(s.size > 0);
	    }
      //Debug.writeLn(obj.__typeName);
    } else {
      //Debug.writeLn("<null>");
    }
  }

  def count:int { get { return _count; } }
  def reset { _count = 0; }
}

class ClassWithPointers {
  var a:String;
  var b:String;
  var c:String;
}

class ClassWithUnion {
  var u:String or int8;

  def construct {
    u = 0;
  }
}

class ClassWithTuple {
  var t:(int,String,String);
}

class StructWithPointer {
  var a:String;

  def construct(a:String) {
    self.a = a;
  }
}

class TraceTest : Test {
  def testTraceString {
    var counter = TraceCounter();
    counter.traceObject("Hello");
    assertEq(1, counter.count);
  }

  def testTraceClassWithPointers {
    var counter = TraceCounter();
    var obj = ClassWithPointers();
    counter.traceObject(obj);
    assertEq(0, counter.count);

    obj.a = "Hello";
    counter.reset();
    counter.traceObject(obj);
    assertEq(1, counter.count);

    obj.b = ", ";
    counter.reset();
    counter.traceObject(obj);
    assertEq(2, counter.count);

    obj.c = "World";
    counter.reset();
    counter.traceObject(obj);
    assertEq(3, counter.count);
  }

  def testTraceClassWithUnion {
    var counter = TraceCounter();
    var obj = ClassWithUnion();
    counter.traceObject(obj);
    assertEq(0, counter.count);

    obj.u = "Hello";
    counter.reset();
    counter.traceObject(obj);
    assertEq(1, counter.count);

    obj.u = 1;
    counter.reset();
    counter.traceObject(obj);
    assertEq(0, counter.count);
  }

  def testTraceClassWithTuple {
    var counter = TraceCounter();
    var obj = ClassWithTuple();
    counter.traceObject(obj);
    assertEq(0, counter.count);

    obj.t = 0, "Hello", "World";
    counter.reset();
    counter.traceObject(obj);
    assertEq(2, counter.count);
  }

  def testTraceStack {
    var counter = TraceCounter();
    GCRuntimeSupport.traceStack(counter);
    assertTrue(counter.count > 0);
  }

  def testTraceStackNullPtr {
    var counter = TraceCounter();
    var s:String = Memory.nullObject();
    GCRuntimeSupport.traceStack(counter);
    var baseCount = counter.count;
    s = "Hello";
    counter.reset();
    GCRuntimeSupport.traceStack(counter);
    assertEq(baseCount + 1, counter.count);
  }

  def testTraceStackUnion {
    var counter = TraceCounter();
    var value:String or void;
    GCRuntimeSupport.traceStack(counter);
    var baseCount = counter.count;
    value = "Hello";
    counter.reset();
    GCRuntimeSupport.traceStack(counter);
    assertEq(baseCount + 1, counter.count);
  }

  def testTraceIntermediateValue {
    // Insure that intermediate values to a function are marked as roots.
    var c1 = getCountForNoValues();
    var c2 = getCountForNoValues();
    var c3 = getCountForIntermediateValues(String("Hello"), String("World"));
    assertEq(c1, c2);
    assertEq(c1 + 2, c3);
  }

  def getCountForNoValues() -> int {
    var counter = TraceCounter();
    GCRuntimeSupport.traceStack(counter);
    return counter.count;
  }

  def getCountForIntermediateValues(s0:String, s1:String) -> int {
    var counter = TraceCounter();
    GCRuntimeSupport.traceStack(counter);
    return counter.count;
  }

  def testTraceLocalScopeVar {
    // Make sure that a variable is not a root when out of scope.
    var counter = TraceCounter();
    GCRuntimeSupport.traceStack(counter);
    var c1 = counter.count;
    var c2:int;
    var c3:int;

    if true {
      var s1 = String("Hello");
      counter.reset();
	    GCRuntimeSupport.traceStack(counter);
    	c2 = counter.count;
    }

    counter.reset();
    GCRuntimeSupport.traceStack(counter);
  	c3 = counter.count;

    assertEq(c1 + 1, c2);
    assertEq(c1, c3);
  }

  def testTraceLocalScopeStructVar {
    // Make sure that a variable is not a root when out of scope.
    var counter = TraceCounter();
    GCRuntimeSupport.traceStack(counter);
    var c1 = counter.count;
    var c2:int;
    var c3:int;

    if true {
      var s1 = StructWithPointer("Hello");
      counter.reset();
	    GCRuntimeSupport.traceStack(counter);
    	c2 = counter.count;
    }

    counter.reset();
    GCRuntimeSupport.traceStack(counter);
  	c3 = counter.count;

    assertEq(c1 + 1, c2);
    assertEq(c1, c3);
  }

  def testTraceArray {
    // Make sure that a variable is not a root when out of scope.
    var counter = TraceCounter();
    var array1 = [1, 2, 3, 4];
    var array2 = ["hello", "world"];
    counter.traceObject(array1);
    assertEq(0, counter.count);
    counter.traceObject(array2);
    assertEq(2, counter.count);
  }

  static var aGlobal:String;

  def testTraceGlobalVar {
    var counter = TraceCounter();
    GCRuntimeSupport.traceStaticRoots(counter);
    var c1 = counter.count;

    // Add a global, should have one more static root.
    aGlobal = "Hello";
    counter.reset();
    GCRuntimeSupport.traceStaticRoots(counter);
    var c2 = counter.count;

    // Add a global, should have one more static root.
    aGlobal = Memory.nullObject();
    counter.reset();
    GCRuntimeSupport.traceStaticRoots(counter);
    var c3 = counter.count;
    //Debug.writeLnFmt("Trace counts: {0} {1} {2}", c1, c2, c3);
    assertEq(c1 + 1, c2);
    assertEq(c1, c3);
  }
}
